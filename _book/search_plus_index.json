{"./":{"url":"./","title":"Introduction","keywords":"","body":"java-note-2020 介绍 Java 学习笔记 all in one 软件架构 软件架构说明 安装教程 xxxx xxxx xxxx 使用说明 xxxx xxxx xxxx 参与贡献 Fork 本仓库 新建 Feat_xxx 分支 提交代码 新建 Pull Request 码云特技 使用 Readme_XXX.md 来支持不同的语言，例如 Readme_en.md, Readme_zh.md 码云官方博客 blog.gitee.com 你可以 https://gitee.com/explore 这个地址来了解码云上的优秀开源项目 GVP 全称是码云最有价值开源项目，是码云综合评定出的优秀开源项目 码云官方提供的使用手册 https://gitee.com/help 码云封面人物是一档用来展示码云会员风采的栏目 https://gitee.com/gitee-stars/ "},"Part-I/99-webmagic爬虫.html":{"url":"Part-I/99-webmagic爬虫.html","title":"WebMagic 爬虫","keywords":"","body":"Web Magic 爬虫框架 使用 Web Magic 时，如果使用的是较低版本的 JDK，会导致一些 https:// 网页无法爬取，所以确保你安装的是 JDK 8，并且使用的是 JDK 8 的编译标准。 pom.xml us.codecraft webmagic-core 0.7.3 us.codecraft webmagic-extension 0.7.3 maven 项目的默认编译级别是 JDK 5，为了『告诉』maven 使用 JDK 8 的标准进行编译（前提是你安装的 JDK 确实是 8 ），需要加入两个 maven 环境变量： UTF-8 1.8 1.8 ... webmagic 使用了 log4j2 日志框架，如果你使用的是其他的日志框架，那记得将它排除掉： org.slf4j slf4j-log4j12 或者干脆就使用 log4j2 日志框架。在 classpath 下提供 log4j2 的配置文件： !FILENAME log4j.properties log4j.rootLogger=WARN, stdout log4j.logger.xxx.yyy.zzz=WARN, stdout log4j.appender.stdout=org.apache.log4j.ConsoleAppender log4j.appender.stdout.layout=org.apache.log4j.PatternLayout log4j.appender.stdout.layout.ConversionPattern=%20t %5p | %m%n 一个简单的例子 !FILENAME ExamplePageProcessor.java import us.codecraft.webmagic.Page; import us.codecraft.webmagic.Site; import us.codecraft.webmagic.Spider; import us.codecraft.webmagic.pipeline.ConsolePipeline; import us.codecraft.webmagic.processor.PageProcessor; import us.codecraft.webmagic.selector.Selectable; public class ExamplePageProcessor implements PageProcessor { // 抓取网站的相关配置，包括：编码、抓取间隔、重试次数等 private Site site = Site.me().setRetryTimes(3).setSleepTime(1000); @Override public void process(Page page) { Selectable selectable = page.getHtml().css(\"div.content\"); System.out.println(selectable); } @Override public Site getSite() { return site; } public static void main(String[] args) { Spider.create(new ExamplePageProcessor()) .addUrl(\"http://my.oschina.net/flashsword/blog\") .run(); } } Page 对象 当指定的页面被 webmagic 爬下来之后，PageProcessor 的 .process() 方法会被触发执行。 webmagic 在调用 .process() 方法时，传入的 Page 对象就代表着所爬下来的页面。其中，最常用的是获得该页面的 URL 和页面内容。 System.out.println(page.getUrl().toString()); System.out.println(page.getHtml().toString()); // 这个字符串会很长... .css() 方法 通过 page.getHtml() 我们可以从代码中拿到所请求的页面的全部内容。但是，通常我们感兴趣/需要的是页面上的某个或某些内容，而非整个页面内容全部。 .css() 方法借用 CSS 选择器的语法，可以让我们从这个页面内容中选中我们感兴趣/需要的元素片段。例如： Selectable selectable = page.getHtml().css(\"div.content\"); System.out.println(selectable.toString()); 这里的 .css() 方法的参数 div.content 的写法和 CSS 选择器的写法是一摸一样，它匹配/选中的是页面上 元素。 .css() 方法返回的是被选中/符合条件的页面元素中的第一个。如果，想获得所有符合条件的元素（而不仅仅是第一个），那么需要多调用一个 .nodes() 方法： List list = page.getHtml().css(\"div.content\").nodes(); 当然，如果页面上有且仅有一个元素符合选中条件，那么，返回的 List 中也就只有一个 Selectable 对象。 CSS 选择器语法见最后。 对于 .css() 方法返回的 Selectable 对象，可以 再次调用 .css() 方法，表示语句此选中的内容（HTML片段）再进一步在其内部进行选择。例如： Selectable selectable1 = page.getHtml().css(\"div.content\"); Selectable selectable2 = selectable1.css(\"div.text\"); System.out.println(selectable2); XPath 和 .xpath() 方法 当通过 .css() 方法选中了你所需要的元素后，你感兴趣的内容可能是这个/这些元素的属性值，或文本内容。更有甚者，还可能是它们的子孙元素的属性值，或文本内容。 这时，你需要对 .css() 方法的返回的 Selectable 再进一步调用 .xpath() 方法。 显而易见，.xpath() 方法利用了 XPath 概念。XPath 是一门在 XML 文档中查找信息的语言。XPath 可用来在 XML 文档中对元素和属性进行遍历。 XPath 最常用的路径表达式： 表达式 描述 nodename 选取此节点的所有子节点。 / 从根节点选取。 // 从匹配选择的当前节点选择文档中的节点，而不考虑它们的位置。 . 选取当前节点。 .. 选取当前节点的父节点。 @ 选取属性。 例如： 路径表达式 结果 bookstore 选取 bookstore 元素，不强求它必须是根元素。 /bookstore 选取 bookstore 元素，并且，它必须是根元素。 bookstore/book 选取 bookstore 元素的名为 book 的子元素。 //book 选取所有 book 子元素，不强求它必须是根元素 bookstore//book 选择属于 bookstore 元素的后代中名为 book 的元素，不强求 book 必须是 bookstore 的直接子元素。 /bookstore/book/title 选取 bookstore 的子元素 book 的子元素 title /bookstore/book[1]/title 选取 bookstore 的第一个 book 子元素的 title 子元素。 /bookstore/book/price/text() 选取 booksotre 元素的 book 子元素的 price 子元素的文本内容 /bookstore/book/@lang 选取 booksotre 元素的 book 子元素的 lang 属性的属性值 一个更复杂的 XPATH：/bookstore/book[@lang='eng']/price/text() 选取 booksotre 元素的 lang 属性值为 eng 的 book 子元素的 price 子元素的文本内容。| 更多的语法和示例可参看 w3school 教程。 @Override public void process(Page page) { System.out.println(page.getUrl().toString()); List selectableList = page.getHtml().css(\"li.fl\").nodes(); for (Selectable selectable : selectableList) { String content = selectable.xpath(\"/li/div/p[1]/a/@href\").get(); if (StringUtils.isNotBlank(content)) System.out.println(content); } } Pipeline 机制和 ConsolePipeline 我们对从『爬』到的页面上『抠』出来的数据的处理（System.out.println()）的处理是写死在 .process() 方法中的。 更优雅的方案是使用 webmagic 的 Pipeline 机制。 在创建 Spider 对象（并启动运行时），你可以指定一个或多个 Pipeline 对象： Spider.create(new ExamplePageProcessor()) .addUrl(\"https://www.1905.com/mdb/film/list/year-2019/\") .addPipeline(new ConsolePipeline()) // 看这里 .run(); 当 PageProcessor 的 .process() 方法执行完后，Pipeline 的 .process() 会执行。 在 PageProcessor 中，你可以将需要后续处理的数据放入到 page 对象中： page.putField(\"xxx\", ...); page.putField(\"yyy\", ...); page.putField(\"zzz\", ...); 在 Pipeline 中，你可以再将上面存在 page 中的数据取出来，再进一步进行处理： resultItems.get(\"xxx\"); resultItems.get(\"yyy\"); resultItems.get(\"zzz\"); 另外，可以通过 lambda 表达式来简化自定义 Pipeline 。 另外，Spider 的 Pipeline 可以有多个。这多个 Pipeline 会依次执行（这才是它较管道的原因）。 Spider.create(new App()) .addUrl(\"http://my.oschina.net/flashsword/blog\") .addPipeline((resultItems, task) -> { System.out.println(\"第 1 个 pipeline 被触发执行\"); }) .addPipeline((resultItems, task) -> { System.out.println(\"第 2 个 pipeline 被触发执行\"); }) .addPipeline((resultItems, task) -> { System.out.println(\"第 3 个 pipeline 被触发执行\"); }) .run(); 你可以利用这个特性实现这样的效果：在第 1 个 Pipeline 中做第一道数据加工操作，在第 2 个 Pipeline 中在做第二道数据加工操作，... 。 page.addTargetRequest() 通常，我们需要爬取的并非一个页面，而是一系列页面。常见的需求是这样：爬取第一个页面，从其中摘取某些信息，并以此为依据构造第二个页面 URL，继续爬取第二个页面，...。 在 Processor 的 .process() 方法中，调用 page.addTargetRequest() 可以动态地告知 Spider 接下来要爬取的页面。整个代码结构类似于： @Override public void process(Page page) { if ( page.getUrl().get() 是页面1 ) { ... page.addTargetRequest(页面2); } else if ( page.getUrl().get() 是页面2 ) { ... page.addTargetRequest(页面3); } else if ( page.getUrl().get() 是页面3 ) { ... } ... } 例如： public class SimpleProcessor implements PageProcessor { private static final Logger log = LoggerFactory.getLogger(App.class); // 抓取网站的相关配置，包括：编码、抓取间隔、重试次数等 private Site site = Site.me().setRetryTimes(3).setSleepTime(1000); @Override public void process(Page page) { if (Objects.equals(page.getUrl().get(), \"https://www.1905.com/mdb/film/list/year-2019\")) { List selectableList = page.getHtml().css(\"li.fl>div\").nodes(); for (Selectable selectable : selectableList) { String idContent = selectable.xpath(\"/div/p[1]/a/@href\").get(); if (StringUtils.isNotBlank(idContent)) { String[] tokens = StringUtils.split(idContent, \"/\"); String id = tokens[tokens.length - 1]; log.info(\"{}\", id); page.addTargetRequest(String.format(\"https://www.1905.com/mdb/film/%s/performer/?fr=mdbypsy_dh_yzry\", id)); } } } else if (StringUtils.startsWith(page.getUrl().get(), \"https://www.1905.com/mdb/film/\") && StringUtils.endsWith(page.getUrl().get(), \"/performer/?fr=mdbypsy_dh_yzry\")) { log.info(\"{}\", page.getUrl().get()); } } @Override public Site getSite() { return site; } public static void main(String[] args) { Spider.create(new SimpleProcessor()) .addUrl(\"https://www.1905.com/mdb/film/list/year-2019\") .run(); } } 多线程 默认情况下，Webmagic 仅使用一个线程（当前线程）爬取网页内容，如果有需要，可以指定多个线程： public static void main(String[] args) { Spider.create(new SimpleProcessor()) .addUrl(\"https://www.1905.com/mdb/film/list/year-2019\") .thread(5) .run(); } 一个关于空格的小问题 有时候你在页面上看到的空格有全角、半角之分，看起来并没有任何区别。但是字符串的 .split() 和 trim() 方法处理的都是半角空格。 所以，你会看到调用了 trim() 方法但是似乎没起作用的情况。 这种情况下可以先将全角空格替换为半角空格之后，再作处理。 content = content.replaceAll(\"\\\\u00A0\",\" \"); 附：CSS 选择器 CSS 选择器决定了后续规则将应用于哪些元素。 CSS 核心选择器 选择器 解释 ``* 选中所有的元素 xxx 选中的元素必须是 xxx 类型元素。即， .xxx 选中的元素的 class 属性的值必须 是/有 xxx 。即，class=\"xxx ...\" #xxx 选中的元素的 id 属性的值必须是 xxx 。即，id=xxx 注意，由于 class 属性的值可以有多个，选中同时具备两个 class 属性值的元素的写法为：.xxx.yyy，即，所选中元素的 class = \"xxx yyy\" 。 CSS 属性选择器 属性选择器是基于属性名及属性的值进行选择页面元素。 选择器 解释 [attr] 选中的元素必须具有 attr 属性。 [attr=\"val\"] 选中的元素必须具有 attr 属性，且属性值为 val。 [attr^=\"val\"] 选中的元素必须具有 attr 属性，且属性值是以 val 开头。 [attr$=\"val\"] 选中的元素必须具有 attr 属性，且属性值是以 val 结尾。 [attr*=\"val\"] 选中的元素必须具有 attr 属性，且属性值含有 val（可以有其他值）。 选择器的复合使用 选择器的复合使用，从程序员的角度来看，就是以 与 和 或 的关系组合使用多个选择器，选择页面元素。 选择器的“与”关系：，将两个选择器“紧挨”在一起，就是以 与 的关系使用选择器选择页面元素。其选择结果必定（必须）同时满足两个选择器。 注意：此处两个选择器间不能有空格。有空格则表达了另一种关系，不再是 与 的关系。 选择器的“或”关系：, ，将两个选择器以逗号（,）分隔，就是以 或 的关系使用选择器选择页面元素。其选择结果只需满足两者其一即可。 注意，此处逗号后的空格可有可无。 亲属关系选择器 亲属关系选择器会涉及到元素的层次结构。 选择器 解释 选中的元素要满足 选择器 2 ，并且，祖先 要满足 选择器 1 。 > 选中的元素要满足 选择器 2 ，并且，爸爸 要满足 选择器 1 。 + 选中的元素要满足 选择器 2 ，并且，紧邻的前一个元素 要满足 选择器 1 。 ~ 选中的元素要满足 选择器 2 ，并且，哥哥 要满足 选择器 1 。 "},"Part-II/spring-boot/02-Java代码配置.html":{"url":"Part-II/spring-boot/02-Java代码配置.html","title":"Spring 中使用 Java 代码配置","keywords":"","body":"Java 代码配置 从 Spring 3.0 开始，Spring 官方就推荐大家使用 java 代码配置来代替以前的 xml 文件配置。而到了 SpringBoot，Java 代码配置更是成了标配。 Java 代码配置主要靠 Java 类和一些注解，比较常用的注解有： 常用注解 说明 @Configuration 声明一个类作为配置类，代替 .xml 文件 @Bean 声明在方法上，将方法的返回值加入Bean容器，代替 标签 @Value 属性注入 @PropertySource 指定外部属性文件 配置 Druid 数据库连接池的简单方式 Spring Boot 默认的数据库连接池是 HikariCP 。spring-boot-starter-parent 中设置了 HIkariCP 的版本信息。因此，如果使用 HikariCP 只用声明你要用它就行，而声明要使用 Druid，你需要自己指定所使用的版本。 引入依赖： mysql mysql-connector-java com.alibaba druid 1.1.6 编写 Java 配置类： @Configuration public class JdbcConfig { @Bean(initMethod = \"init\", destroyMethod = \"close\") public DataSource dataSource() { DruidDataSource dataSource = new DruidDataSource(); dataSource.setDriverClassName(\"com.mysql.cj.jdbc.Driver\"); dataSource.setUrl(\"jdbc:mysql://192.168.119.130:3306/scott?serverTimezone=UTC&useUnicode=true&characterEncoding=utf-8&useSSL=false\"); dataSource.setUsername(\"root\"); dataSource.setPassword(\"123456\"); return dataSource; } } 以上代码配置等同于如下的 .xml 配置： 代码配置中引用关系的表示 上面的 DruidDataSource ，我们为其属性赋值时，它的四个属性都是简单类型属性，因此十分容易处理。但是，在 Spring 的容器中，Java Bean 可能会存在引用。 在 .xml 配置文件中，我们是通过 ref 属性为引用类型的属性赋值的。 例如： 而在 Java 代码配置中，有三种方式来配置 Java Bean 的引用关系（其中，推荐第三种）： 通过方法调用表示引用关系 如果两个 Java Bean 在同一个配置类中，可使用这种方式： @Bean public Employee employee() { Employee employee = new Employee(); employee.setId(10); employee.setName(\"tom\"); employee.setSalary(2000.0); employee.setDepartment(department()); return employee; } @Bean public Department department() { Department department = new Department(); department.setId(1); department.setName(\"研发部\"); department.setLocation(\"北京\"); return department; } 通过 @Autowire 表示引用关系 如果两个 Java Bean 分别在不同的 配置类中，可使用这种方式： @Autowired public Department department; @Bean public Employee employee() { Employee employee = new Employee(); employee.setId(10); employee.setName(\"tom\"); employee.setSalary(2000.0); employee.setDepartment(department); return employee; } 通过参数表示引用关系 无论两个 Java Bean 是在不同的配置类中，还是在同一个配置类中，都可使用这种方式： @Bean public Employee employee(Department department) { Employee employee = new Employee(); employee.setId(10); employee.setName(\"tom\"); employee.setSalary(2000.0); employee.setDepartment(department); return employee; } Druid 数据库连接池配置 v2 在上面的 Druid 的配置中，数据库连接的四大属性值是在代码中『写死』的。我们可以把它们『抽取』出来放在配置文件中。 配置文件 jdbc.properties jdbc.driverClassName = com.mysql.cj.jdbc.Driver jdbc.url = jdbc:mysql://127.0.0.1:3306/scott jdbc.username = root jdbc.password = 123456 在配置类中可以结合 @PropertySource 和 @Value 注解，让 Spring 从指定配置文件中读取数据，再注入到配置类中。 配置类 @Configuration @PropertySource(\"classpath:jdbc.properties\") // 这里 public class JdbcConfig { @Value(\"${jdbc.url}\") // 这里 String url; @Value(\"${jdbc.driverClassName}\") // 这里 String driverClassName; @Value(\"${jdbc.username}\") // 这里 String username; @Value(\"${jdbc.password}\") // 这里 String password; @Bean public DataSource dataSource() { DruidDataSource dataSource = new DruidDataSource(); dataSource.setUrl(url); dataSource.setDriverClassName(driverClassName); dataSource.setUsername(username); dataSource.setPassword(password); return dataSource; } } Druid 数据库连接池配置 v3 由于 Spring Boot 项目启动时，一定会加载项目的配置文件 application.properties，所以，我们可以直接将自定义的配置项写在 application.properties 中，而不必再单独的创建一个配置文件。 这种写法本质上，和上述的 jdbc.properties 的写法是一样的。 截至到这里，日常编程中的配置工作大体也就是如此。理论上，还有再进一步改进优化的余地，但是总体来说，必要性已经不大了。（可能，还把简单问题复杂化了）。 附：Druid 数据库连接池配置 v4 在配置类中，我们有四个属性用于接收/获取配置文件中的四项配置的值。我们可以将这个四个属性（及其功能）抽取到另一个单独的类中，从而使配置类的代码更简洁。 注意，这里我们需要使用一个叫 @EnableConfigurationProperties 的注解，为此，我们需要在 pom 中多引入一个依赖： org.springframework.boot spring-boot-configuration-processor true JdbcProperties： @ConfigurationProperties(prefix = \"jdbc\") // 去掉前缀 @PropertySource(\"classpath:application.properties\") public class JdbcProperties { private String url; private String driverClassName; private String username; private String password; /* * 其实，并不是严格要求属性文件中的属性名与成员变量名一致。 * 支持驼峰，中划线，下划线等转换。 */ // getter / setter ... } 配置类： @Configuration @EnableConfigurationProperties(JdbcProperties.class) // 这里 public class SpringDaoConfig { @Bean public DataSource dataSource(JdbcProperties jdbc) { // 这里 ... } } "},"Part-II/spring-boot/01-基础.html":{"url":"Part-II/spring-boot/01-基础.html","title":"Spring Boot 基础","keywords":"","body":"SpringBoot 基础 Spring Boot 是由 Pivotal 团队提供的基于 Spring 的全新框架，其设计目的是为了简化 Spring 应用的搭建和开发过程。该框架遵循『约定大于配置』原则，采用特定的方式进行配置，从而使开发者无需定义大量的 XML 配置。通过这种方式，Spring Boot 致力于在蓬勃发展的快速应用开发领域成为领导者。 Spring Boot 并不重复造轮子，而且在原有 Spring 的框架基础上封装了一层，并且它集成了一些类库（提供了默认的配置），用于简化开发。 简而言之，Spring Boot 就是一个大容器，其中包含了很多类库的默认配置，你只需要在项目中引入这些类库即可使用。 基本概念 SpringBoot 是 Spring 项目中的一个子工程，推崇约定大于配置的方式以便于你能够尽可能快速的启动并运行程序。 由于 SpringBoot 使用一些固定的方式来构建生产级别的 spring 应用，所有人们把 SpringBoot 称为搭建程序的 脚手架。 SpringBoot 简化了基于 Spring 的应用开发，只需要 run 就能创建一个独立的、生产级别的 Spring 应用。 SpringBoot 为 Spring 平台及第三方库提供开箱即用的设置（提供默认设置，存放默认配置的包就是启动器），这样我们就可以简单的开始。 多数 SpringBoot 应用只需要很少的 Spring 配置。 我们可以使用 SpringBoot 创建 java 应用，并使用 java –jar 启动它，就能得到一个生产级别的 web 工程。 SpringBoot 主要特点和目标是： 为所有 Spring 的开发者提供一个非常快速的、广泛接受的入门体验 开箱即用（启动器 `starter-* 其实就是 SpringBoot 提供的一个 jar 包），但通过自己设置参数（*.properties* 或 *.yml`* ），即可快速摆脱这种方式。 提供了一些大型项目中常见的非功能性特性，如内嵌服务器、安全、指标，健康检测、外部化配置等 绝对没有代码生成，也无需 XML 配置。 创建 SpringBoot 项目 创建一个 Maven 项目，但是不用勾选 Create from archetype。截止目前为止，该项目与 SpringBoot 还没有任何关系。 SpringBoot 提供了一个名为 spring-boot-starter-parent 的工程，里面已经对各种常用依赖（并非全部）的版本进行了管理，我们的项目需要以这个项目为父工程，这样我们就不用操心依赖的版本问题了，需要什么依赖，直接引入坐标即可！ 添加父工程坐标： org.springframework.boot spring-boot-starter-parent 2.1.11.RELEASE 添加 web 启动器： org.springframework.boot spring-boot-starter-web 需要注意的是，我们并没有在这里指定版本信息。因为 Spring Boot 的 父工程 已经对版本进行了管理了。 这些都是 Spring Boot 根据 spring-boot-starter-web 这个依赖自动引入的，而且所有的版本都已经管理好，不会出现冲突。 完整 pom 如下所示： 4.0.0 org.springframework.boot spring-boot-starter-parent 2.1.11.RELEASE hemiao3000.gitee.io springboot-demo 1.0-SNAPSHOT 1.8 org.springframework.boot spring-boot-starter-web 编码 编写启动类 SpringBoot 项目通过 main 函数即可启动，我们需要创建一个启动类： @SpringBootApplication public class Application { public static void main(String[] args) { SpringApplication.run(SpringbootDemo1Application.class, args); } } 写 Controller 接下来的编码工作，就是正常的 Spring MVC 项目的开发过程。 @RestController public class HelloController { @GetMapping(\"/hello\") public String helo() { return \"hello world\"; } } 运行 / 测试 运行启动类的 main 方法，会在控制台中看见日志信息，其中有一条信息如下： Tomcat started on port(s): 8080 (http) with context path '' 监听的端口是 8080 Spring MVC 的映射路径是：/ /hello 路径已经映射到了 HelloController 中的 hello() 方法 打开页面访问：http://localhost:8080/hello properties 和 yaml Spring Boot 整个应用程序只有一个配置文件，那就是 .properties 或 .yml 文件。如果你的 Spring Boot 项目中没有包含这个配置文件，Spring Boot 对每个配置项都有默认值（当然，我们也可以添加配置文件，用以覆盖其默认值）。 这里以 .properties 文件为例，首先在 resources 下新建一个名为 applicatioon.properties（必须是这个名字）的文件。 输入内容为： server.port=8081 server.servlet.context-path=/api 并且启动 main 方法，这时程序请求地址则变成了：http://localhost:8081/api/hello 。 Spring Boot 支持 properties 和 yaml 两种格式的文件，文件名分别对应 application.properties 和 application.yml。 下面贴出 yaml 文件格式供大家参考： server: port: 8080 servlet: context-path: /api 可以看出 yaml 则 换行 + tab 隔开。这里需要注意的是冒号后面 必须空格，否则会报错。 日志 Spring Boot 直接使用 slf4j ，默认间接使用 logback 日志，因此，它支持直接在 .properties 和 .yml 文件中对日志的相关信息进行配置。 另外，Spring Boot 还支持控制台日志上色功能。 logging.level.root=INFO logging.level.xxx.yyy.zzz=DEBUG logging.pattern.console=${CONSOLE_LOG_PATTERN:\\ %clr(${LOG_LEVEL_PATTERN:%5p}) \\ %clr(|){faint} \\ %clr(%-40.40logger{39}){cyan} \\ %clr(:){faint} %m%n\\ ${LOG_EXCEPTION_CONVERSION_WORD:%wEx}} 有一点需要注意，如果是 .yml 文件格式，在设置 logging.pattern.console 时，其值必须用双引号括起来，形如：console=\"...\" 。 "},"Part-II/spring-boot/03-自动配置.html":{"url":"Part-II/spring-boot/03-自动配置.html","title":"Spring Boot 自动配置","keywords":"","body":"自动配置 SpringBoot 通过 自动配置 简化了大量的繁复的配置信息。 启动类 Application 中有两处特别之处： 注解：@SpringBootApplication run 方法：SpringApplication.run(...) @SpringBootApplication 注解至少等价于以下三个注解： @SpringBootConfiguration 该是来声明当前类是 SpringBoot 应用的配置类，一个项目中只能有一个。 因为该注解的存在，Spring 会再去『找』所有添加了 @Configuration 的类，做相应的操作。 @EnableAutoConfiguration 该注解的作用是告诉 Spring Boot 基于 .pom 文件中添加的的 starter 依赖，进行自动配置。 例如，我们引入了 spring-boot-starter-web，而这个启动器中帮我们添加了 tomcat、Spring MVC 的依赖。 SpringBoot 内部对大量的第三方库或 Spring 内部库进行了默认配置，这些配置是否生效，取决于我们是否引入了对应 starter 。 @ComponentScan 该注解提供了类似与 标签的作用。 通过 basePackageClasses 或者 basePackages 属性来指定要扫描的包。如果没有指定这些属性，那么将从声明这个注解的类所在的包开始，扫描包及子包。 因此，启动类需要放在一个比较前/浅的包目录中 。 spring-boot-autoconfigure.jar 中的 org.springframework.boot.autoconfigure 包下包含了各种框架/库的默认配置。 由 Spring 负责提供的 用于快速整合 XXX 框架/组件的自动配置快速整合包，通常的命名规则是：spring-boot-starter-xxx 。例如： spring-boot-starter-tomcat spring-boot-starter-thymleaf 这种由 Spring 提供的自动配置快速整合的包，其版本信息在 spring-boot-parent 中已定义，（除非是真有需要，否则）不需要指定版本信息。 由 XXX 框架/组件方负责提供的用于与 Spring 快速整合的包， 通常的命名规则是： xxx-spring-boot-starter 。例如： mybatis-spring-boot-starter druid-spring-boot-starter 这种由 XXX 方提供的自动配置快速整合包，需要指定版本信息。 "},"Part-II/spring-boot/04-spring-boot-jsp.html":{"url":"Part-II/spring-boot/04-spring-boot-jsp.html","title":"Spring Boot 中使用 JSP","keywords":"","body":"Spring Boot 项目中使用 JSP 想在 Spring Boot 中使用 JSP，需要满足一些特殊要求。 项目结构 Spring Boot 项目想要支持 JSP，其项目结构必须如下： spring-boot-jsp │── pom.xml └── src ├── main │ ├── java │ ├── resouces │ └── webapp │ └── WEB-INF │ └── jsp │ └── welcome.jsp └── test 在配置文件 application.properties 中进行配置： spring.mvc.view.prefix=/WEB-INF/jsp/ spring.mvc.view.suffix=.jsp spring.mvc.view.prefix 指明 jsp 文件在 webapp 下的哪个目录 spring.mvc.view.suffix 指明 jsp 以什么样的后缀结尾 引入依赖包 org.springframework.boot spring-boot-starter-web javax.servlet jstl org.apache.tomcat.embed tomcat-embed-jasper spring-boot-starter-web 包依赖了 spring-boot-starter-tomcat，因此，后者不再需要单独配置； jstl 是一个 JSP 的 jstl 标签库； tomcat-embed-jasper 主要用来支持 JSP 的解析和运行。 编写页面和后台 Time: ${time} Message: ${message} @Controller public class WelcomeController { @GetMapping(\"/\") public String welcome(Model model) { model.addAttribute(\"time\", new Date()); model.addAttribute(\"message\", \"hello world\"); return \"welcome\"; } } 运行方式一：Maven 命令运行 cmd 进入项目根路径下，执行： mvn clean spring-boot:run 补充：Idea 的 Maven 工具窗口中，有个 M 图标，通过点击它在弹出的窗口中可直接手动执行 maven 命令。 运行方式二：在 IDEA 中运行 如果像其他项目一样，直接在 IDEA 中通过 main 方法来启动项目，在访问测试的时候会出现 404 not found 。 这是因为 Spring Boot JSP 项目需要额外进行一个设置：选择 Edit Configurations 选项，打开 Configuration，为 Working directory 赋值为项目的根目录。 运行方式三：打 war 包部署运行 step 1：在 pom.xml 里设置打包格式为 war 。 war step 2：排除内嵌的 Tomcat 依赖，避免 jar 包冲突。 org.springframework.boot spring-boot-starter-web org.springframework.boot spring-boot-starter-tomcat step 3：添加 Servlet 的支持 Spring Boot 项目必须实现 SpringBootServletInitializer 接口的 configure() 方法才能让外部容器运行 Spring Boot 项目。 在启动类同目录下创建 ServletInitializer 类： public class ServletInitializer extends SpringBootServletInitializer { @Override protected SpringApplicationBuilder configure(SpringApplicationBuilder application) { return application.sources(JspApplication.class); } } step 4：maven 命令打包 在项目根目录下执行： mvn clean package step 5：发布运行 将项目 target 目录下的 .war 包拷贝到 tomcat 的 webapps 目录下，运行 tomcat 的 bin 目录下的 startup.bat 启动 tomcat 。 在浏览器中访问即可。 "},"Part-II/spring-boot/05-thymeleaf基础.html":{"url":"Part-II/spring-boot/05-thymeleaf基础.html","title":"Spring Boot 中使用 Thymeleaf","keywords":"","body":"Thymeleaf Thymeleaf 简介 Thymeleaf 旨在提供一个优雅的、高度可维护的创建模板的方式。为了实现这一目标，Thymeleaf 建立在自然模板的概念上，将其逻辑注入到模板文件中，不会影响模板设计原型，从而改善了设计的沟通，弥合了设计和开发团队之间的差距。 Thymeleaf 从设计之初就遵循 Web 标准——特别是 HTML 5 标准，如果需要，Thymeleaf 允许创建完全符合 HTML 5 验证标准的模板。 Spring Boot 体系内推荐使用 Thymeleaf 作为前端页面模板，并且 Spring Boot 2.0 中默认使用 Thymeleaf 3.0，性能提升幅度很大。 与其他的模板引擎（JSP、Velocity、FreeMarker）相比较，它有如下三个极吸引人的特点： Thymeleaf 可以在浏览器查看页面的静态效果。 Thymeleaf 开箱即用的特性。它支持标准方言和 Spring 方言，可以直接套用模板实现 JSTL、OGNL 表达式效果。 Thymeleaf 方便与 SpringMVC 集成。 对比 Velocity、FreeMarker 与 Thymeleaf 打印出同一条消息： Velocity: $message FreeMarker: ${message} Thymeleaf: Hello World! 上面我们可以看出来 Thymeleaf 的作用域在 HTML 标签内，类似标签的一个属性来使用，这就是它的特点。 快速上手 pom.xml org.springframework.boot spring-boot-starter-thymeleaf application.properties spring.thymeleaf.cache=false logging.level.root=INFO logging.level.xxx.yyy.zzz=DEBUG logging.pattern.console=${CONSOLE_LOG_PATTERN:\\ %clr(${LOG_LEVEL_PATTERN:%5p}) \\ %clr(|){faint} \\ %clr(%-40.40logger{39}){cyan} \\ %clr(:){faint} \\ %m%n${LOG_EXCEPTION_CONVERSION_WORD:%wEx}} 关闭 Thymeleaf 的缓存。不然在开发过程中修改页面不会立即生效需要重启，生产可配置为 true 。 一个简单的页面 Hello Hello World 所有使用 Thymeleaf 的页面 必须 在 HTML 标签声明 Thymeleaf： 表明页面使用的是 Thymeleaf 语法。 Controller @Controller public class HelloController { @RequestMapping(\"/\") public String index(ModelMap map) { map.addAttribute(\"message\", \"http://www.baidu.com\"); return \"hello\"; } } 常用语法 赋值、字符串拼接 赋值和拼接： 我是默认值 我是默认值 字符串拼接还有另外一种简洁的写法（推荐）： 我是默认值 string.html 页面： ... text 我是默认值 我是默认值 我是默认值 后端传值： @RequestMapping(\"/string\") public String string(ModelMap map) { map.addAttribute(\"userName\", \"baidu\"); return \"string\"; } 条件判断 If/Unless Thymeleaf 中使用 th:if 和 th:unless 属性进行条件判断，在下面的例子中， 标签只有在 th:if 中条件成立时才显示： 示例： 163 baidu th:unless 与 th:if 恰好相反，只有表达式中的条件立，才会显示其内容。 页面 if.html： If/Unless 163 baidu 后端传值： @RequestMapping(\"/if\") public String ifunless(ModelMap map) { map.addAttribute(\"flag\", \"yes\"); return \"if\"; } for 循环 for 循环在我们项目中使用的频率太高，一般结合前端的表格来使用。 在后端定义一个列表，以键 users，传递到前端： @RequestMapping(\"/list\") public String list(ModelMap map) { User user1 = new User(\"大牛\",12,\"123456\"); User user2 = new User(\"小牛\",6,\"123563\"); User user3 = new User(\"纯洁的微笑\",66,\"666666\"); List list = new ArrayList(); list.add(user1); list.add(user2); list.add(user3); map.addAttribute(\"users\", list); return \"list\"; } list.html 进行数据展示： ... for 循环 neo 6 213 index iterStat 称作状态变量，属性有： 属性 | 说明 index | 当前迭代对象的 index （从 0 开始计算） count | 当前迭代对象的 index （从 1 开始计算） size | 被迭代对象的大小 current | 当前迭代变量 even/odd | 布尔值，当前循环是否是偶数/奇数（从 0 开始计算） first | 布尔值，当前循环是否是第一个 last | 布尔值，当前循环是否是最后一个 页面展示效果 for 循环 大牛 12 123456 0 小牛 6 123563 1 纯洁的微笑 66 666666 2 URL 处理 需要特别注意的是 Thymeleaf 对于 URL 的处理是通过语法 @{...} 来处理的。如果需要 Thymeleaf 对 URL 进行渲染，那么务必使用 th:href、th:src 等属性。 示例： link1 view 几点说明： 上例中 URL 最后的 (pageId=${pageId}) 表示将括号内的内容作为 URL 参数处理，该语法避免使用字符串拼接，大大提高了可读性； @{...} 表达式中可以通过 {pageId} 访问 Context 中的 pageId 变量； @{/order} 是 Context 相关的相对路径，在渲染时会自动添加上当前 Web 应用的 Context 名字，假设 context 名字为 app，那么结果应该是 /app/order 。 页面内容： ... URL link1 view 后端程序： @RequestMapping(\"/url\") public String url(ModelMap map) { map.addAttribute(\"type\", \"link\"); map.addAttribute(\"pageId\", \"springcloud/2017/09/11/\"); map.addAttribute(\"img\", \"http://www.baidu.com/assets/images/neo.jpg\"); return \"url\"; } 三目运算 三目运算是我们常用的功能之一，普遍应用在各个项目中。 例如： 说明： 表示如果 age 大于 30 则输入框中显示中年，否则显示青年。 三目运算符关键字： 关键字 | 说明 gt | great than（大于） ge | great equal（大于等于） eq | equal（等于） lt | less than（小于） le | less equal（小于等于） ne | not equal（不等于） 结合三目运算也可以将上面的 if else 改成这样： 百度 页面内容： ... EQ 百度 后端程序： @RequestMapping(\"/eq\") public String eq(ModelMap map) { map.addAttribute(\"name\", \"neo\"); map.addAttribute(\"age\", 30); map.addAttribute(\"flag\", \"yes\"); return \"eq\"; } 页面效果： EQ neo 青年 百度 单击 百度 链接会跳转到：http://www.baidu.com/ 地址。 switch 选择 switch/case 多用于多条件判断的场景下。 以性别举例： Example switch 她是一个姑娘... 这是一个爷们! 未知性别的一个家伙。 后端程序： @RequestMapping(\"/switch\") public String switchcase(ModelMap map) { map.addAttribute(\"sex\", \"woman\"); return \"switch\"; } 在浏览器中输入网址：http://localhost:8080/switch。 页面展示效果如下： 她是一个姑娘... 可以在后台改 sex 的值来查看结果。 『完』 "},"Part-II/spring-boot/06-spring-boot-mybatis.html":{"url":"Part-II/spring-boot/06-spring-boot-mybatis.html","title":"Spring Boot 集成 Mybatis","keywords":"","body":"pringBoot 整合 Mybatis 什么是 MyBatis-Spring-Boot-Starter mybatis-spring-boot-starter 是 MyBatis 帮助我们快速集成 SpringBoot 提供的一个组件包，使用这个组件可以做到以下几点： 构建独的应用 几乎可以零配置 需要很少的 XML 配置 mybatis-spring-boot-starter 依赖于 MyBatis-Spring 和 SpringBoot，最新版 1.3.2 需要 MyBatis-Spring 1.3 以上，SpringBoot 版本 1.5 以上。 注意 mybatis-spring-boot-starter 是 MyBatis 官方开发的 Starter，而不是 Spring Boot 官方开发的启动包。mybatis-spring-boot-starter 支持 XML 配置和注解配置两种。不过考虑到使用 mybatis-generator 生成 .xml 配置文件和 Example 对象的便捷性，优先考虑使用 xml 配置。 关键依赖包 mybatis-spring-boot-starter 的 pom 文件，现在最新版本是 2.1.0 。 org.mybatis.spring.boot mybatis-spring-boot-starter 2.1.0 application 配置 !FILENAME application.properties spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver spring.datasource.url=jdbc:mysql://localhost:3306/scott\\ ?useUnicode=true\\ &characterEncoding=utf-8\\ &useSSL=true\\ &serverTimezone=UTC spring.datasource.username=root spring.datasource.password=123456 # jdbc-starter 中自带了一个连接池：HikariCP spring.datasource.hikari.idle-timeout=60000 spring.datasource.hikari.maximum-pool-size=30 spring.datasource.hikari.minimum-idle=10 mybatis.config-location=classpath:mybatis/mybatis-config.xml mybatis.mapper-locations=classpath:mybatis/mapper/*.xml logging.level.root=INFO logging.level.hemiao3000.gitee.io=DEBUG logging.pattern.console=${CONSOLE_LOG_PATTERN:\\ %clr(${LOG_LEVEL_PATTERN:%5p}) \\ %clr(|){faint} \\ %clr(%-40.40logger{39}){cyan} \\ %clr(:){faint} \\ %m%n${LOG_EXCEPTION_CONVERSION_WORD:%wEx}} 其中： 配置 说明 mybatis.config-locations 配置 mybatis-config.xml 路径，mybatis-config.xml 中配置 MyBatis 基础属性； mybatis.mapper-locations 配置 Mapper 对应的 XML 文件路径； mybatis.type-aliases-package 配置项目中实体类包路径； spring.datasource.* 数据源配置。 如果你需要使用 Druid 连接池，也可以使用 Druid 官方提供的启动器： com.alibaba druid-spring-boot-starter 1.1.10 而连接信息的配置与上面类似（四大连接属性不变），只不过在连接池特有属性上，方式略有不同： # 初始化连接数 spring.datasource.druid.initial-size=1 # 最小空闲连接 spring.datasource.druid.min-idle=1 # 最大活动连接 spring.datasource.druid.max-active=20 SpringBoot 启动时数据源会自动注入到 SqlSessionFactory 中，使用 SqlSessionFactory 构建 SqlSessionFactory，再自动注入到 Mapper 中，最后我们直接使用 Mapper 即可。 启动类 在启动类中添加对 Mapper 包扫描 @MapperScan，SpringBoot 启动的时候会自动加载包径下的 Mapper 。 @SpringBootApplication @MapperScan(\"com.xja.mapper\") public class Application { public static void main(String[] args) { SpringApplication.run(Application.class, args); } } 或者直接在 Mapper/DAO 类上面添加注解 @Mapper，建议使用上面那种，不然每个 mapper 加个注解也挺麻烦的。 如果使用的是 Idea，注入 DAO 时经常会报 could not autowire，Eclipse 却没有问题，其实代码是正确的，这是 Idea 的误报。可以选择降低 Autowired 检测的级别，不要提示就好。 在 File | Settings | Editor | Inspections 选项中使用搜索功能找到 Autowiring for Bean Class，将 Severity 的级别由之前的 error 改成 warning 即可。 "},"Part-II/spring-boot/07-spring-boot-jpa.html":{"url":"Part-II/spring-boot/07-spring-boot-jpa.html","title":"Spring Boot 集成 JPA","keywords":"","body":"Spring Data JPA 的基本使用 基本概念 JPA 由来 从理论上来说，Mybatis 和 Hibernate 并非同一类框架：Mybatis 是半自动 ORM 框架，而 Hibernate 是全自动的。 而从全自动 ORM 框架的角度来将，Hibernate 也非唯一的一个，跟它同类的竞争对手还有：TopLink、JDO 等（虽然市场占有率十分低） 。 不同的全自动（这里并不包括 Mybatis）之间，功能是是相似的，但是 API 接口的区别十分大。不便于项目在底层技术实现之间迁移。 JPA（Java Persistence API）是 Sun 官方提出的 Java 持久化 规范。它的出现主要是为了简化现有的持久化开发工作和整合 ORM 技术，提供统一的 API 接口，结束现在 Hibernate、TopLink、JDO 等 ORM 框架各自为营的局面。 注意：JPA 只是一套规范，不是一套产品。JPA 和 Hibernate、TopLink、JDO 之间的关系，就像 slf4j 和 log4j2、logback 之间的关系一样。 Spring Data JPA 一个项目直接（或间接）使用 Hibernate 有三种方式： 直接使用 Hibernate。 直接使用 JPA，间接使用 Hibernate； 通过 spring-data-jpa，将 JPA（和 Hibernate）整合进 Spring 项目，以一种特定的方式（sprig data）使用 JPA，从而间接使用 Hibernate 。 Spring Data JPA 是 Spring 基于 ORM 框架、JPA 规范的基础上封装的一套 JPA 应用框架。如果说，JPA 简化了 Hibernate 的使用，那么 spring-data-jpa 则是在这个基础上再一次简化了 hibernate，提高了开发效率。Spring Data JPA 让我们摆脱了 DAO 层的操作，基本上所有 CRUD 都可以依赖于它实现。 Spring Data JPA 其实就是要求在 Spirng Data 的体系下使用 JPA。Spring Data JPA 只是 Spring Data 体系中的一员。 快速上手 添加依赖 org.springframework.boot spring-boot-starter-data-jpa mysql mysql-connector-java 添加配置文件 spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver spring.datasource.url=jdbc:mysql://127.0.0.1:3306/scott\\ ?useUnicode=true\\ &characterEncoding=utf-8\\ &useSSL=true\\ &serverTimezone=UTC spring.datasource.username=root spring.datasource.password=123456 spring.jpa.show-sql=true spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL5Dialect spring.jpa.properties.hibernate.format_sql=true spring.jpa.properties.hibernate.hbm2ddl.auto=update logging.level.root=INFO logging.level.hemiao3000.gitee.io=DEBUG logging.pattern.console=${CONSOLE_LOG_PATTERN:\\ %clr(${LOG_LEVEL_PATTERN:%5p}) \\ %clr(|){faint} \\ %clr(%-40.40logger{39}){cyan} \\ %clr(:){faint} \\ %m%n${LOG_EXCEPTION_CONVERSION_WORD:%wEx}} hibernate.hbm2ddl.auto 参数的作用主要用于：自动创建、更新、验证数据库表结构，有四个值。 值 说明 create 每次加载 Hibernate 时都会删除上一次生成的表，然后根据 model 类再重新来生成新表，哪怕两次没有任何改变也要这样执行，这就是导致数据库表数据丢失的一个重要原因。 create-drop 每次加载 Hibernate 时根据 model 类生成表，但是 sessionFactory 一关闭，表就自动删除。 update 最常用的属性，第一次加载 Hibernate 时根据 model 类会自动建⽴立起表的结构（前提是先建立好数据库），以后加载 Hibernate 时根据 model 类自动更新表结构，即使表结构改变了，但表中的行仍然存在，不会删除以前的行。要注意的是当部署到服务器后，表结构是不会被马上建立起来的，是要等应用第一次运行起来后才会。 validate 每次加载 Hibernate 时，验证创建数据库表结构，只会和数据库中的表进行比较，不会创建新表，但是会插入新值。 实体类 /* * DBMS - catalog - schema - table * Mysql - - database - table */ @Entity @Table(name=\"表名\", schema =\"数据库名\") public class User { @Id @GeneratedValue private Long id; @Column(nullable = false, unique = true) private String userName; @Column(nullable = false) private String passWord; @Column(nullable = false, unique = true) private String email; @Column(nullable = true, unique = true) private String nickName; @Column(nullable = false) private String regTime; // getter / settet ... } @Entity(name=\"EntityName\") 必须 用来标注一个数据库对应的实体，数据库中创建的表名默认和类名一致。其中，name 为可选,对应数据库中一个表，使用此注解标记 JavaBean 是一个 JPA 实体。 @Table(name=\"\", catalog=\"\", schema=\"\") 可选 用来标注一个数据库对应的实体，数据库中创建的表名默认和类名一致。通常和 @Entity 配合使用，只能标注在实体的 class 定义处，表示实体对应的数据库表的信息。 在数据库理论领域中，DBMS - Catalog - Schema - Table 是四级概念，但不是所有的数据库系统都支持这四级。MySql 就不支持其中的 catalog ，而 schema 就是 mysql 中的 database 。 @Id 必须 @Id 定义了映射到数据库表的主键的属性，一个实体只能有一个属性被映射为主键。 @GeneratedValue(strategy=GenerationType, generator=\"\") 可选 strategy：表示主键生成策略,有 AUTO、INDENTITY、SEQUENCE 和 TABLE 4 种。 generator：表示主键生成器的名称。 @Column(name=\"user_code\", nullable=false, length=32) 可选 @Column 描述了数据库表中该字段的详细定义，这对于根据 JPA 注解生成数据库表结构的工具。 name：表示数据库表中该字段的名称，默认情形属性名称一致; nullable：表示该字段是否允许为 null，默认为 true; unique：表示该字段是否是唯一标识，默认为 false; length：表示该字段的大小，仅对 String 类型的字段有效。 @Transient 可选 @Transient 表示该属性并非一个到数据库表的字段的映射，ORM 框架将忽略该属性。 @Enumerated 可选 使用枚举的时候，我们希望数据库中存储的是枚举对应的 String 类型，而不是枚举的索引值，需要在属性上面添加 @Enumerated(EnumType.STRING) 注解。 UUID 和 ASSIGNED 主键策略 通常 JPA【背后】是 Hibernate，而 Hibernate 除了和上述的一样的 identity、sequence 主键生成策略之外，还有 uuid 和 assigend 两种主键生成策略。 在 JPA 中使用 Hibernate 的 uuid 和 assigend 策略，需要【多】使用一个注解：@GenericGenerator 。 !FILENAME uuid @Id @GeneratedValue(generator = \"xxx\") @GenericGenerator(name = \"xxx\", strategy = \"uuid\") private String id; !FILENAME assigend @Id @GeneratedValue(generator = \"yyy\") @GenericGenerator(name = \"yyy\", strategy = \"assigned\") private Long id; Repository 构建 如果是直接使用 Hibernate 或 JPA，即便是最简单的查询操作，都是从获取核心对象 Session 开始。 由于我们是在 Spring Data 体系下使用 JPA，我们对于 JPA 的使用，就如同之前的 spring-data-redis（未来的 spring-data-elasticsearch）一样，继承 Spring Data 体系中的某个 Repository 接口，因此获得一套『现成』的增删改查一套方法。 创建的 Repository 只要继承 JpaRepository 即可，就会帮我们自动生成很多内置方法。 另外还有一个功能非常实用，可以根据方法名自动生产 SQL，比如 .findByUserName() 会自动生产一个以 userName 为参数的查询方法，比如 .findAll() 会自动查询表里面的所有数据等。 @Repository public interface UserRepository extends JpaRepository { User findByUserName(String userName); User findByUserNameOrEmail(String username, String email); } 我们只需要在对应的 Repository 中创建好方法，使用的时候直接将接口注入到类中调用即可。 JpaRepository 继承 PagingAndSortingRepository 和 QueryByExampleExecutor。PagingAndSortingRepository 又继承了 CrudRepository 。 CrudRepository 内置了我们最常用的增、删、改、查的方法。 PagingAndSortingRepository 类在 CrudRepository 基础上负责排序和分⻚，QueryByExampleExecutor 提供了很多示例的查询方法。 因此使用 JPA 操作数据库时，只需要构建的 Repository 继承了 JpaRepository，就会拥有了很多常用的数据库操作方法。 自定义查询 Spring Data JPA 可以根据接口方法名来实现数据库操作，主要的语法是 findXXBy、readAXXBy、 queryXXBy、countXXBy、getXXBy 后面跟属性名称，利用这个功能仅需要在定义的 Repository 中添加对应的方法名即可，使用时 Spring Boot 会自动帮我们实现，示例如下。 根据用户名查询用户： User findByUserName(String userName); 也可以加⼀一些关键字 And、or： User findByUserNameOrEmail(String username， String email); 修改、删除、统计也是类似语法： Long deleteById(Long id); Long countByUserName(String userName); 基本上 SQL 体系中的关键词都可以使用，如 LIKE 、IgnoreCase、OrderBy： List findByEmailLike(String email); User findByUserNameIgnoreCase(String userName); List findByUserNameOrderByEmailDesc(String email); 可以根据查询的条件不断地添加和拼接，Spring Boot 都可以正确解析和执行，其他使用示例例可以参考下表。 具体的关键字，使用方法和生产成 SQL 如下表所示 Keyword Sample JPQL snippet And findByLastnameAndFirstname … where x.lastname = ?1 and x.firstname = ?2 Or findByLastnameOrFirstname … where x.lastname = ?1 or x.firstname = ?2 Is, Equals findByFirstnameIs, findByFirstnameEquals … where x.firstname = ?1 Between findByStartDateBetween … where x.startDate between ?1 and ?2 LessThan findByAgeLessThan … where x.age LessThanEqual findByAgeLessThanEqual … where x.age GreaterThan findByAgeGreaterThan … where x.age > ?1 GreaterThanEqual findByAgeGreaterThanEqual … where x.age >= ?1 After findByStartDateAfter … where x.startDate > ?1 Before findByStartDateBefore … where x.startDate IsNull findByAgeIsNull … where x.age is null IsNotNull, NotNull findByAge(Is)NotNull … where x.age not null Like findByFirstnameLike … where x.firstname like ?1 NotLike findByFirstnameNotLike … where x.firstname not like ?1 StartingWith findByFirstnameStartingWith … where x.firstname like ?1 (parameter bound with appended %) EndingWith findByFirstnameEndingWith … where x.firstname like ?1 (parameter bound with prepended %) Containing findByFirstnameContaining … where x.firstname like ?1 (parameter bound wrapped in %) OrderBy findByAgeOrderByLastnameDesc … where x.age = ?1 order by x.lastname desc Not findByLastnameNot … where x.lastname <> ?1 In findByAgeIn(Collection ages) … where x.age in ?1 NotIn findByAgeNotIn(Collection age) … where x.age not in ?1 TRUE findByActiveTrue() … where x.active = true FALSE findByActiveFalse() … where x.active = false IgnoreCase findByFirstnameIgnoreCase … where UPPER(x.firstame) = UPPER(?1) JPA 高级查询： 自定义 SQL 查询 @Query 使用 Spring Data 大部分的 SQL 都可以根据方法名定义的方式来实现，但是由于某些原因必须使用自定义的 SQL 来查询，Spring Data 也可以完美支持。 在 SQL 的查询方法上面使用 @Query 注解，在注解内写 Hql 来查询内容。 @Query(\"select u from User u\") Page findALL(Pageable pageable); 当然如果感觉使用原生 SQL 更习惯，它也是支持的，需要再添加一个参数 nativeQuery = true 。 @Query(\"select * from user u where u.nick_name = ?1\", nativeQuery = true) Page findByNickName(String nickName, Pageable pageable); @Query 上面的 ?1 代表的是方法参数里面的顺序，如果有多个参数也可以按照这个方式添加 1、2、3....。除了按照这种方式传参外，还可以使用 @Param 来支持。 @Query(\"select u from User u where u.nickName = :xxx\") Page findByNickName(@Param(\"xxx\") String nickName, Pageable pageable); 如涉及到删除和修改需要加上 @Modifying，也可以根据需要添加 @Transactional 对事务的支持、操作超时设置等（以下仅作演示。@Transactional 注解应该用于 Service 层方法）。 @Transactional(timeout = 10) @Modifying @Query(\"update User set userName = ?1 where id = ?2\") int modifyById(String userName, Long id); @Transactional @Modifying @Query(\"delete from User where id = ?1\") void deleteById(Long id); 使用已命名的查询 除了使用 @Query 注解外，还可以预先定义好一些查询，并为其命名，然后再 Repository 中添加相同命名的方法。 定义命名的 Query： @Entity @NamedQueries({ @NamedQuery(name = \"DAO接口名.方法名\", query = \"HQL语句\"), @NamedQuery(name = \"User.findByPassWord\", query = \"select u from User u where u.passWord = ?1\"), @NamedQuery(name = \"User.findByNickName\", query = \"select u from User u where u.nickName = ?1\"), @namedQuery(name = \"...\", query = \"...\"), @namedQuery(name = \"...\", query = \"...\"), @namedQuery(name = \"...\", query = \"...\"), }) public class User { …… } 通过 @NamedQueries 注解可以定义多个命名 Query，@NamedQuery 的 name 属性定义了 Query 的名称，注意加上 . 作为前缀，query 属性定义查询语句。 定义对应的方法： List findByPassWord(String passWord); List findByNickName(String nickName); JPA 高级查询： 分页查询和限制查询 Spring Data JPA 已经帮我们内置了分页功能，在查询的方法中，需要传入参数 Pageable，当查询中有多个参数的时候 Pageable 建议 作为最后一个参数传入。 @Query(\"select u from User u\") Page findALL(Pageable pageable); Page findByNickName(String nickName, Pageable pageable); // Pageable pageable = PageRequest.of(0, 3); Pageable 是 Spring 封装的分页实现类，使用的时候需要传入页数、每页条数和排序规则，Page 是 Spring 封装的分页对象，封装了总页数、分页数据等。返回对象除使用 Page 外，还可以使用 Slice 作为返回值。 Slice findByNickNameAndEmail(String nickName, String email, Pageable pageable); Page 和 Slice 的区别如下: Page 接口继承自 Slice 接口，而 Slice 继承自 Iterable 接口。 Page 接口扩展了 Slice 接口，添加了获取总页数和元素总数量的方法，因此，返回 Page 接口时，必须执行两条 SQL，一条复杂查询分页数据，另一条负责统计数据数量。 返回 Slice 结果时，查询的 SQL 只会有查询分页数据这一条，不统计数据数量。 用途不一样：Slice 不需要知道总页数、总数据量，只需要知道是否有下一页、上一页，是否是首页、尾页等，比如前端滑动加载一页可用；而 Page 知道总页数、总数据量，可以用于展示具体的页数信息，比如后台分页查询。 实例： @Test public void testPageQuery() { int page=1, size=2; Sort sort = new Sort(Sort.Direction.DESC, \"id\"); Pageable pageable = PageRequest.of(page, size, sort); userRepository.findALL(pageable); userRepository.findByNickName(\"aa\", pageable); } Sort，控制分页数据的排序，可以选择升序和降序。 PageRequest，控制分页的辅助类，可以设置页码、每页的数据条数、排序等。 限制查询 有时候我们只需要查询前 N 个元素，或者只取前一个实体。 User findFirstByOrderByLastnameAsc(); User findTopByOrderByAgeDesc(); Page queryFirst10ByLastname(String lastname, Pageable pageable); List findFirst10ByLastname(String lastname, Sort sort); List findTop10ByLastname(String lastname, Pageable pageable); JPA 高级查询： 复杂查询 我们可以通过 AND 或者 OR 等连接词来不断拼接属性来构建多条件查询，但如果参数大于 6 个时，方法名就会变得非常的长，并且还不能解决动态多条件查询的场景。到这里就需要给大家介绍另外一个利器 JpaSpecificationExecutor 了。 JpaSpecificationExecutor 是 JPA 2.0 提供的 Criteria API 的使用封装，可以用于动态生成 Query 来满足我们业务中的各种复杂场景。Spring Data JPA 为我们提供了 JpaSpecificationExecutor 接口，只要简单实现 toPredicate 方法就可以实现复杂的查询。 我们来看一下 JpaSpecificationExecutor 的源码： public interface JpaSpecificationExecutor { // 根据 Specification 条件查询单个对象，注意的是，如果条件能查出来多个会报错 T findOne(@Nullable Specification spec); // 根据 Specification 条件查询 List 结果 List findAll(@Nullable Specification spec); // 根据 Specification 条件，分页查询 Page findAll(@Nullable Specification spec, Pageable pageable); // 根据 Specification 条件，带排序的查询结果 List findAll(@Nullable Specification spec, Sort sort); // 根据 Specification 条件，查询数量 long count(@Nullable Specification spec); } JpaSpecificationExecutor 的源码很简单，根据 Specification 的查询条件返回 List、Page 或者 count 数据。 在使用 JpaSpecificationExecutor 构建复杂查询场景之前，我们需要了解几个概念： 概念 说明 Root root 代表了可以查询和操作的实体对象的根，可以通过 get(\"属性名\") 来获取对应的值。 CriteriaQuery query 代表一个 specific 的顶层查询对象，它包含着查询的各个部分，比如 select、from、where、group by、order by 等。 CriteriaBuilder cb 来构建 CritiaQuery 的构建器器对象，其实就相当于条件或者是条件组合，并以 Predicate 的形式返回。 使用案例 首先定义一个 UserDetail 对象，作为演示的数据模型。 @Entity public class UserDetail { @Id @GeneratedValue private Long id; @Column(nullable = false, unique = true) private Long userId; private Integer age; private String realName; private String status; private String hobby; private String introduction; private String lastLoginIp; } 创建 UserDetail 对应的 Repository： public interface UserDetailRepository extends JpaSpecificationExecutor, JpaRepository { } 定义一个查询 Page\\ 的接口： public interface UserDetailService { public Page findByCondition(UserDetailParam detailParam, Pageable pageable); } 在 UserDetailServiceImpl 中，我们来演示 JpaSpecificationExecutor 的具体使用。 @Service public class UserDetailServiceImpl implements UserDetailService { @Autowired private UserDetailRepository userDetailRepository; @Override public Page findByCondition(Map params, Pageable pageable) { return userDetailRepository.findAll((root, query, cb) -> { List predicates = new ArrayList(); // equal 示例：“introduction = xxx” Predicate predicate1 = cb.equal(root.get(\"introduction\"), arg1); // like 示例：realName like ? Predicate predicate2 = cb.like(root.get(\"realName\"), \"%\" + arg2); // between 示例：age between (?, ?) Predicate predicate3 = cb.between(root.get(\"age\"), arg3, arg4); // greaterThan 大于等于示例 Predicate predicate4 = cb.greaterThan(root.get(\"age\"), arg5); // where A and B and (C or D) return cb.and( predicate1, predicate2, cb.or(predicate3, predicate4) ); }, pageable); } } 上面的示例是根据不同条件来动态查询 UserDetail 分页数据，UserDetailParam 是参数的封装，示例中使用了常用的大于、like、等于等示例，根据这个思路我们可以不断扩展完成更复杂的动态 SQL 查询。 使用时只需要将 UserDetailService 注入调用相关方法即可： @RunWith(SpringRunner.class) @SpringBootTest public class JpaSpecificationTests { @Autowreid private UserDetailService userDetailService; @Test public void testFindByCondition() { int page=0,size=10; Sort sort = new Sort(Sort.Direction.DESC, \"id\"); Pageable pageable = PageRequest.of(page, size, sort); UserDetailParam param = new UserDetailParam(); param.setIntroduction(\"程序员\"); param.setMinAge(10); param.setMaxAge(30); Page page1=userDetailService.findByCondition(param, pageable); for (UserDetail userDetail:page1){ System.out.println(\"userDetail: \"+userDetail.toString()); } } } JPA 高级查询： 多表查询 多表查询在 Spring Data JPA 中有两种实现方式，第一种是利用 Hibernate 的级联查询来实现，第二种是创建一个结果集的接口来接收连表查询后的结果，这里主要介绍第二种方式。 我们还是使用上面的 UserDetail 作为数据模型来使用，定义一个结果集的接口类，接口类的内容来自于用户表和用户详情表。 public interface UserInfo { String getUserName(); String getEmail(); String getAddress(); String getHobby(); } 在运行中 Spring 会给接口（UserInfo）自动生产一个代理类来接收返回的结果，代码中使用 getXXX() 的形式来获取。 在 UserDetailRepository 中添加查询的方法，返回类型设置为 UserInfo： @Query(\"select u.userName as userName, u.email as email, d.address as address, d.hobby as hobby from User u, UserDetail d where u.id = d.userId and d.hobby = ?1 \") List findUserInfo(String hobby); 特别注意这里的 SQL 是 HQL，需要写类的名和属性，这块很容易出错。 测试验证： @Slf4j @Test public void testUserInfo() { List userInfos=userDetailRepository.findUserInfo(\"钓鱼\"); for (UserInfo userInfo: userInfos) { log.info(\"userInfo: {}-{}-{}-{}\", userInfo.getUserName(), userInfo.getEmail(), userInfo.getHobby(), userInfo.getIntroduction()); } } 运行测试方法后返回： userInfo: aa-aa@126.com-钓鱼-程序员 证明关联查询成功，最后的返回结果来自于两个表，按照这个思路可以进行三个或者更多表的关联查询。 open session in view 启动类（或某个配置类）中加入 @Bean public OpenEntityManagerInViewFilter openEntityManagerInViewFilter() { return new OpenEntityManagerInViewFilter(); } 配置文件中加入 spring.jpa.open-in-view=true 。 『The End』 "},"Part-II/spring-boot/08-spring-boot-redis.html":{"url":"Part-II/spring-boot/08-spring-boot-redis.html","title":"Spring Boot 集成 Redis","keywords":"","body":"SpringBoot 中使用 Redis Redis 介绍 Redis 是一个 速度非常快的非关系数据库（Non-Relational Database） 它可以存储键（Key）与 5 种不同类型的值（Value）之间的映射（Mapping） 可以将存储在内存的键值对数据持久化到硬盘 可以使用复制特性来扩展读性能 还可以使用客户端分片来扩展写性能 为了满足高性能，Redis 采用内存（in-memory）数据集，根据使用场景，可以通过每隔一段时间转储数据集到磁盘，或者追加每条命令到日志来持久化。 持久化也可以被禁用，如果你只是需要一个功能丰富、网络化的内存缓存。 数据模型 Redis 数据模型不仅与关系数据库管理系统（RDBMS）不同，也不同于任何简单的 NoSQL 键-值数据存储。 Redis 数据类型类似于编程语言的基础数据类型，因此开发人员感觉很自然，每个数据类型都支持适用于其类型的操作，受支持的数据类型包括: 类型 说明 string 字符串 hash 哈希 list 列表 set 集合 zset sorted set:有序集合 关键优势 Redis 的优势包括它的速度、对富数据类型的支持、操作的原子性，以及通用性: # 优势 1 性能极高，它每秒可执行约 10，000 个 SET 以及约 100，000 个 GET 操作; 2 丰富的数据类型，Redis 对大多数开发人员已知的大多数据类型提供了原生支持，这使得各种问题得以轻松解决; 3 原子性，因为所有 Redis 操作都是原子性的，所以多个客户端会并发地访问一个 Redis 服务器，获取相同的更新值; 4 丰富的特性，Redis 是一个多效用工具，有非常多的应用场景，包括缓存、消息队列（Redis 原生支持发布/订阅）、短期应用程序数据（比如 Web 会话、Web 页面命中计数）等。 spring-boot-starter-data-redis Spring Boot 提供了对 Redis 集成的组件包：spring-boot-starter-data-redis，它依赖于 spring-data-redis 和 lettuce 。 另外，这里还有两个小细节： Spring Boot 1.x 时代，spring-data-redis 底层使用的是 Jedis；2.x 时代换成了 Lettuce 。 Lettuce 依赖于 commons-pool2 。 库 说明 Lettuce 一个可伸缩线程安全的 Redis 客户端，多个线程可以共享同一个 RedisConnection，它利用优秀 Netty NIO 框架来高效地管理多个连接。 Spring Data Spring 框架中的一个主要项目，目的是为了简化构建基于 Spring 框架应用的数据访问，包括非关系数据库、Map-Reduce 框架、云数据服务等，另外也包含对关系数据库的访问支持。 Spring Data Redis Spring Data 项目中的一个主要模块，实现了对 Redis 客户端 API 的高度封装，使对 Redis 的操作更加便捷。 可以用以下方式来表达它们之间的关系: Lettuce -> Spring Data Redis -> Spring Data -> spring-boot-starter-data-redis 快速上手 引入依赖包 org.springframework.boot spring-boot-starter-data-redis org.apache.commons commons-pool2 引入 commons-pool2 是因为 Lettuce 需要使用 commons-pool2 创建 Redis 连接池。 application 配置 # Redis 服务器地址 spring.redis.host=localhost # Redis 服务器连接端口 spring.redis.port=6379 # Redis 数据库索引(默认为 0) spring.redis.database=0 # Redis 服务器连接密码(默认为空) spring.redis.password= # 以下非必须，有默认值 # 连接池最大连接数(使用负值表示没有限制) 默认 8 spring.redis.lettuce.pool.max-active=8 # 连接池最大阻塞等待时间(使用负值表示没有限制) 默认 -1 spring.redis.lettuce.pool.max-wait=-1 # 连接池中的最大空闲连接 默认 8 spring.redis.lettuce.pool.max-idle=8 # 连接池中的最小空闲连接 默认 0 spring.redis.lettuce.pool.min-idle=0 测试使用 在单元测试中，注入 RedisTemplate 。String 是最常用的一种数据类型，普通的 key-value 存储都可以归为此类，value 其实不仅是 String 也可以是数字。 @RunWith(SpringRunner.class) @SpringBootTest public class TestRedisTemplate { @Autowired private RedisTemplate redisTemplate; @Test public void testString() { redisTemplate.opsForValue().set(\"hello\", \"world\"); Assert.assertEquals(\"world\", redisTemplate.opsForValue().get(\"hello\")); } } 在这个单元测试中，我们使用 redisTemplate 存储了一个字符串 \"world\" ，存储之后获取进行验证，多次进行 set 相同的 key，键对应的值会被覆盖。 Spring Data Redis 针对 api 进行了重新归类与封装，将同一类型的操作封装为 Operation 接口： 专有操作 说明 ValueOperations string 类型的数据操作 ListOperations list 类型的数据操作 SetOperations set 类型数据操作 ZSetOperations zset 类型数据操作 HashOperations map 类型的数据操作 @Autowired private RedisTemplate redisTemplate; @Test public void contextLoad() { assertNotNull(redisTemplate); ValueOperations operations1 = redisTemplate.opsForValue(); ListOperations operations2 = redisTemplate.opsForList(); SetOperations operations3 = redisTemplate.opsForSet(); ZSetOperations operations4 = redisTemplate.opsForZSet(); HashOperations operations5 = redisTemplate.opsForHash(); } 各类型实践 实体 @Slf4j @Test public void testObj() { ValueOperations operations = redisTemplate.opsForValue(); operations.set(\"id\", \"9527\"); operations.set(\"name\", \"tom\"); operations.set(\"age\", \"21\"); String name = operations.get(\"name\"); log.info(\"{}\", name); } 超时失效 Redis 在存入每一个数据的时候都可以设置一个超时间，过了这个时间就会自动删除数据。 新建一个 Student 对象，存入 Redis 的同时设置 100 毫秒后失效，设置一个线程暂停 1000 毫秒之后，判断数据是否存在并打印结果。 @Test public void testExpire() throws InterruptedException { Student user = new Student(\"tom\", 20); ValueOperations operations = redisTemplate.opsForValue(); operations.set(\"expire\", user, 100, TimeUnit.MILLISECONDS); Thread.sleep(1000); boolean exists = redisTemplate.hasKey(\"expire\"); if (exists) { System.out.println(\"exists is true\"); } else { System.out.println(\"exists is false\"); } } 输出结果: exists is false 从结果可以看出，Reids 中已经不存在 Student 对象了，此数据已经过期，同时我们在这个测试的方法中使用了 hasKey(\"expire\") 方法，可以判断 key 是否存在。 删除数据 有些时候，我们需要对过期的缓存进行删除，下面来测试此场景的使用。首先 set 一个字符串“ityouknow”，紧接着删除此 key 的值，再进行判断。 redisTemplate.delete(\"key\"); Hash（哈希） 一般我们存储一个键，很自然的就会使用 get/set 去存储，实际上这并不是很好的做法。Redis 存储一个 key 会有一个最小内存，不管你存的这个键多小，都不会低于这个内存，因此合理的使用 Hash 可以帮我们节省很多内存。 Hash Set 就在哈希表 Key 中的域（Field）的值设为 value。如果 Key 不存在，一个新的哈希表被创建并进行 HSET 操作;如果域（field）已经存在于哈希表中，旧值将被覆盖。 先来看 Redis 对 Pojo 的支持，新建一个 Student 对象（需要实现 Serializable 接口），放到缓存中，再取出来。 @Test public void testHash() { HashOperations hash = redisTemplate.opsForHash(); hash.put(\"tom\", \"name\", \"tom\"); hash.put(\"tom\", \"age\", \"20\"); String value = (String) hash.get(\"tom\", \"name\"); log.info(\"hash value : {}\", value); } 输出结果: hash value :tom 根据上面测试用例发现，Hash set 的时候需要传入三个参数，第一个为 key，第二个为 field，第三个为存储的值。一般情况下 Key 代表一组数据，field 为 key 相关的属性，而 value 就是属性对应的值。 List Redis List 的应用场景非常多，也是 Redis 最重要的数据结构之一。 使用 List 可以轻松的实现一个队列， List 典型的应用场景就是消息队列，可以利用 List 的 Push 操作，将任务存在 List 中，然后工作线程再用 POP 操作将任务取出进行执行。 @Test public void testList() { ListOperations list = redisTemplate.opsForList(); list.leftPush(\"list\", \"it\"); list.leftPush(\"list\", \"you\"); list.leftPush(\"list\", \"know\"); String value = (String)list.leftPop(\"list\"); log.info(\"list value : {}\", value.toString()); } 输出结果: list value :know 上面的例子我们从左侧插入一个 key 为 \"list\" 的队列，然后取出左侧最近的一条数据。其实 List 有很多 API 可以操作，比如从右侧进行插入队列，从右侧进行读取，或者通过方法 range 读取队列的一部分。接着上面的例子我们使用 range 来读取。 List values=list.range(\"list\", 0, 2); for (String v : values) { System.out.println(\"list range :\" + v); } 输出结果: list range :know list range :you list range :it range 后面的两个参数就是插入数据的位置，输入不同的参数就可以取出队列中对应的数据。 Redis List 的实现为一个双向链表，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销，Redis 内部的很多实现，包括发送缓冲队列等也都是用的这个数据结构。 Set Redis Set 对外提供的功能与 List 类似，是一个列表的功能，特殊之处在于 Set 是可以自动排重的，当你需要存储一个列表数据，又不希望出现重复数据时，Set 是一个很好的选择，并且 Set 提供了判断某个成员是否在一个 Set 集合内的重要接口，这个也是 List 所不能提供的。 @Test public void testSet() { String key = \"set\"; SetOperations set = redisTemplate.opsForSet(); set.add(key, \"it\"); set.add(key, \"you\"); set.add(key, \"you\"); set.add(key, \"know\"); Set values = set.members(key); for (String v : values) { System.out.println(\"set value :\" + v); } } 输出结果: set value :it set value :know set value :you 通过上面的例子我们发现，输入了两个相同的值“you”，全部读取的时候只剩下了一条，说明 Set 对队列进行了自动的排重操作。 Redis 为集合提供了了求交集、并集、差集等操作，可以非常方便的使用。 测试 difference SetOperations set = redisTemplate.opsForSet(); String key1 = \"setMore1\"; String key2 = \"setMore2\"; set.add(key1, \"it\"); set.add(key1, \"you\"); set.add(key1, \"you\"); set.add(key1, \"know\"); set.add(key2, \"xx\"); set.add(key2, \"know\"); Set diffs = set.difference(key1, key2); for (String v : diffs) { System.out.println(\"diffs set value :\" + v); } 输出结果: diffs set value :it diffs set value :you 根据上面这个例子可以看出，ldifference() 函数会把 key1 中不同于 key2 的数据对比出来。 测试 unions SetOperations set = redisTemplate.opsForSet(); String key3 = \"setMore3\"; String key4 = \"setMore4\"; set.add(key3, \"it\"); set.add(key3, \"you\"); set.add(key3, \"xx\"); set.add(key4, \"aa\"); set.add(key4, \"bb\"); set.add(key4, \"know\"); Set unions = set.union(key3, key4); for (String v : unions) { log.info(\"unions value : {}\", v); } 输出结果: unions value : know unions value : you unions value : xx unions value : it unions value : bb unions value : aa 根据例子我们发现，unions 会取两个集合的合集，Set 还有其他很多类似的操作，非常方便我们对集合进行数据处理。 Set 的内部实现是一个 Value 永远为 null 的 HashMap，实际就是通过计算 Hash 的方式来快速排重，这也是 Set 能提供判断一个成员是否在集合内的原因 ZSet Redis Sorted Set 的使用场景与 Set 类似，区别是 Set 不是自动有序的，而 Sorted Set 可以通过用户额外提供一个优先级（Score）的参数来为成员排序，并且是插入有序，即自动排序。 在使用 Zset 的时候需要额外的输入一个参数 Score，Zset 会自动根据 Score 的值对集合进行排序，我们可以利用这个特性来做具有权重的队列，比如普通消息的 Score 为 1，重要消息的 Score 为 2，然后工作线程可以选择按 Score 的倒序来获取工作任务。 @Test public void testZset() { String key = \"zset\"; redisTemplate.delete(key); ZSetOperations zset = redisTemplate.opsForZSet(); zset.add(key, \"it\", 1); zset.add(key, \"you\", 6); zset.add(key, \"know\", 4); zset.add(key, \"neo\", 3); Set zsets = zset.range(key, 0, 3); for (String v : zsets) { log.info(\"zset value : {}\", v); } Set zsetB = zset.rangeByScore(key, 0, 3); for (String v : zsetB) { log.info(\"zsetB value : {}\", v); } } 输出结果: zset value : it zset value : neo zset value : know zset value : you zsetB value : it zsetB value : neo 通过上面的例子我们发现插入到 Zset 的数据会自动根据 Score 进行排序，根据这个特性我们可以做优先队列等各种常见的场景。 另外 Redis 还提供了 rangeByScore 这样的一个方法，可以只获取 Score 范围内排序后的数据。 Redis Sorted Set 的内部使用 HashMap 和跳跃表（SkipList）来保证数据的存储和有序，HashMap 里放的是成员到 Score 的映射，而跃表里存放的是所有的成员，排序依据是 HashMap 里存的 Score，使用跳跃表的结构可以获得比较高的查找效率，并且在实现上比较简单。 Redis Repositories Spring Data Redis 从 1.7 开始提供 Redis Repositories ，可以无缝的转换并存储 domain objects，使用的数据类型为哈希（hash）。 Spring Data Redis 的 Repository 的基本实现为：CrudRepository 。 基础用法（Usage） 第一步：启用 Repository 功能 编写一个配置类（或直接利用 Spring Boot 的入口类），在其上标注 @EnableRedisRepositories，表示启用 Repository 功能。 第二步：注解需要缓存的实体 添加关键的两个注解 @RedisHash 和 @Id; @RedisHash(\"user\") public class User implements Serializable { private static final long serialVersionUID = 1L; @Id private Long id; private String userName; private String password; private String email; } 注解 说明 @RedisHash 表示将 User 类的对象都对于 Redis 中的名为 user 的 Set 中。 @Id 标注于对象的唯一性标识上。 如果将多个 User 对象通过 Repository 存储于 Redis 中，那么，它们每个的 key 分别是：*user: 。例如：user:1、user:2、user:3、... 获取它们每个对象的属性的命令为： hget user:1 userName Spring Data Redis 的默认映射规则： Simple Type String firstname = \"rand\" firstname = \"rand\" Complex Type Address adress = new Address(\"河南\", \"郑州\"); address.privince = \"河南\" address.city=\"郑州\" List of Simple Type List nicknames = [\"...\", \"...\", \"...\"] nicknames.[0] = \"dragon reborn\", nicknames.[1] = \"lews therin\" Map of Simple Type Map atts = { key1:val1, key2:val2 } atts.[key1] = \"val1\" atts.[key2] = \"val2\" List of Complex Type List\\ addresses = [ {...}, {...}, {...} ] addresses.[0].province = \"emond’s field\", addresses.[0].city = \"...\", addresses.[1].procinvce = \"...\", addresses.[1].city = \"…​ Map of Complex Type Map addresses = {key1: {}, key2: {}} addresses.[key1].city = \"emond’s field\", addresses.[key2].city = \"…​\" 第三步：创建一个 Repository 接口 自定的 Repository 接口必须继承 CrudRepository，才能“天生”具有存取数据的能力。 public interface UserRepository extends CrudRepository { } "},"Part-II/spring-boot/09-spring-session.html":{"url":"Part-II/spring-boot/09-spring-session.html","title":"Spring Boot 集成 spring-session","keywords":"","body":"Spring Session 实现 Session 共享 Session 共享问题 在微服务架构中，往往由多个微服务共同支撑前端请求，如果涉及到用户状态就需要考虑分布式 Session 管理问题。 比如用户登录请求分发在 服务器A ，用户购买请求分发到了服务器B ， 那么 服务器B 就必须可以获取到用户的登录信息，否则就会影响正常交易。 因此，在分布式架构或微服务架构下，必须保证一个应用服务器上保存 Session 后，其他应用服务器可以同步或共享这个 Session 。 目前主流的分布式 Session 管理有两种方案： Session 复制功能 部分 Web 服务器（例如，Tomcat）能够支持 Session 复制功能。用户可以通过修改 Web 服务器的配置文件，让 Web 服务器进行 Session 复制，保持每一个服务器节点的 Session 数据都能达到一致。 这种方案的局限性在于： 依赖于 Web 服务器。不是所有的 Web 服务器都提供这种功能。 每个 Web 服务器节点都会保存所有的 Session 对象，从而导致内存资源的浪费。 Session 集中存储 在单独的服务器（或服务器集群）上使用缓存技术集中管理所有的 Session 对象。所有的 Web 服务器都从这个存储介质中存取对应的 Session，实现 Session 共享。 Spring Session Spring Session 提供了一套创建和管理 Servlet HttpSession 的方案。它默认采用外置的 Redis 来存储 Session 数据，以此来解决 Session 共享的问题。 Spring 为 Spring Session 和 Redis 的集成提供了组件：spring-session-data-redis 。 快速集成 pom.xml org.springframework.boot spring-boot-starter-data-redis org.apache.commons commons-pool2 org.springframework.session spring-session-data-redis 注意：这个 spring-session-... 并不是 spring-session-core，虽然它引用到了 spring-session-core 。引入这个包的时候请注意一下。 配置文件 # Redis 配置 # Redis 数据库索引（默认为0） spring.redis.database=0 # Redis 服务器地址 spring.redis.host=localhost # Redis 服务器连接端口 spring.redis.port=6379 # Redis 服务器连接密码（默认为空） spring.redis.password= # 以下配置非本功能必须 # 连接池最大连接数（使用负值表示没有限制） spring.redis.lettuce.pool.max-active=8 spring.redis.lettuce.pool.max-wait=-1 spring.redis.lettuce.shutdown-timeout=100 spring.redis.lettuce.pool.max-idle=8 spring.redis.lettuce.pool.min-idle=0 配置类 @Configuration @EnableRedisHttpSession(maxInactiveIntervalInSeconds = 86400*30) public class SessionConfig { } maxInactiveIntervalInSeconds：设置 Session 失效时间，使用 Redis Session 之后，原 Spring Boot 中 的 server.session.timeout 属性不再生效。 至此，spring boot 的 session 共享功能配置结束。 验证 在 Web 层写两个方法进行验证。当然，偷懒一点，你可以将这里测试用的 @RestController 连通上面的 @Configuration 一起写在 spring boot 的启动类中。类似如下： @RestController @EnableRedisHttpSession(maxInactiveIntervalInSeconds = 86400 * 30) @SpringBootApplication public class Application { public static void main(String[] args) { SpringApplication.run(Application.class, args); } @RequestMapping(value = \"/set\") public Map setSession(HttpServletRequest request) { Map map = new HashMap<>(); request.getSession().setAttribute(\"message\", request.getRequestURL()); request.getSession().setAttribute(\"hello\", \"world\"); map.put(\"sessionId\", request.getSession().getId()); map.put(\"request Url\", request.getRequestURL()); return map; } @RequestMapping(value = \"/get\") public Object getSession(HttpServletRequest request) { Map map = new HashMap<>(); map.put(\"sessionId\", request.getSession().getId()); map.put(\"message\", request.getSession().getAttribute(\"message\")); map.put(\"hello\", request.getSession().getAttribute(\"hello\")); return map; } } 复制一份本项目（或在 Idea 中启动两次，注意端口冲突问题），分别从两个 URL 中访问/触发 Session 的存取功能。 "},"Part-II/spring-boot/10-spring-cache.html":{"url":"Part-II/spring-boot/10-spring-cache.html","title":"Spring Boot 集成 spring-cache","keywords":"","body":"Spring Boot 中使用 Cache 缓存 基本概念 绝大多数的网站/系统，最先遇到性能瓶颈就是数据库，而且绝大多数的网站/系统的业务对数据库的操作都是读多写少。使用缓存做数据库的前置缓存，可以非常有效地降低数据库的压力，从而提升整个系统的响应效率和并发量。 大部分使用缓存的场景是基于数据库的缓存，这类缓存场景的逻辑往往是：如果缓存中存在数据，就从缓存中读取；如果缓存中不存在数据，就再从数据库中读取。 为了简化业务代码中的相关逻辑判断，Spring 在 3.1 版本引入了了基于注释驱动的 Spring Cache。它的原理是 Spring Cache 利用了 Spring AOP 的动态代理技术，在项目启动的时候动态生成它的代理类，在代理类中实现了对应的逻辑。 Spring Cache 它本质上不是一个具体的缓存实现方案，而是一个对缓存使用的抽象。简单来说，它相当于是 slf4j，它并不是真正干活的那个。 使用 Spring Cache 的好处： # 好处 1 提供基本的 Cache 抽象，方便切换各种底层 Cache； 2 通过注解 Cache 可以实现类似于事务一样，缓存逻辑透明的应用到我们的业务代码上，且只需要更少的代码就可以完成； 3 提供事务回滚时也自动回滚缓存； 4 支持比较复杂的缓存逻辑； Spring Boot 中 Cache 的使用 Spring Boot 提供了非常简单的解决方案，其中最核⼼的是三个注解： # 注解 1 @Cacheable 2 @CacheEvict 3 @CachePut spring-boot-starter-cache 是 Spring Boot 体系内提供使⽤用 Spring Cache 的 Starter 包。 org.springframework.boot spring-boot-starter-cache 它会进行缓存的自动化配置和识别，Spring Boot 为 Redis 自动配置了 RedisCacheConfiguration 等信息，spring-boot-starter-cache 中的注解也主要是使用了 Spring Cache 提供的支持。 整合 EHCache 初试 Spring Cache EhCache 是一个纯 Java 的进程内缓存框架，具有快速、精干等特点，Hibernate 中的默认 Cache 就是使用的 EhCache 。 @EnableCaching ... implements Serializable pom.xml net.sf.ehcache ehcache ehcache.xml @Cacheable @Cacheable 注解标注于查询方法上。被标注了该注解的方法的返回值，会被 Sprig Cache 存入缓存，并且在调用中先从缓存中获取。缓存中没有，才会执行该查询方法本身的逻辑（从数据库中查询）。 例如： @RequestMapping(\"/hello\") @Cacheable(value=\"helloCache\") public String hello(String name) { log.info(\"没有走缓存！\"); return \"hello \" + name; } 先后两次访问 http://localhost:8080/hello?name=ben 你会发现只有一个日志输出。 @Cacheable 支持如下几个参数： 参数 说明 value 缓存的名称。在 spring 配置文件中定义，必须指定⾄至少一个 key 缓存的 key，可以为空。如果指定，则要按照 SpEL 表达式编写；如果不指定，则缺省按照方法的所有参数进行组合。 condition 触发条件，只有满足条件的情况才会加入缓存，默认为空，既表示全部都加入缓存，支持 Spring EL 。 上述方法可以改造成： @RequestMapping(\"/condition\") @Cacheable(value=\"condition\", condition=\"#name.length() 在浏览器多次访问 http://localhost:8080/condition?name=justicando，会发现日志一次输出 没有缓存，这就是因为参数 name 不满足 length() 的要求（只有满足要求才会走缓存逻辑）。 总结： 当执行到一个被 @Cacheable 注解的方法时，Spring 首先检查 condition 条件是否满足; 如果不满足，执行方法，返回； 如果满足，在缓存空间中查找使用 key 存储的对象， 如果找到，将找到的结果返回， 如果没有找到，执行方法，将方法的返回值以 key-value 对象的方式存如缓存中，然后方法返回。 需要注意的是：当一个支持缓存的方法在对象内部被调用时是不不会触发缓存功能的。 @Cacheable 可以标注于类上。其效果等同于类下所有方法都标注了该注解。 用于 Repository 上 @Cacheable(cacheNames = \"cache\", key = \"#a0\") Hibernate: select account0_.id as id1_0_0_, account0_.amount as amount2_0_0_, account0_.name as name3_0_0_ from account account0_ where account0_.id=? INFO | com.softeem.CqrsDemo3ApplicationTests : Optional[Account{id=1, name='tommy', amount=1000.0}] Hibernate: select account0_.id as id1_0_0_, account0_.amount as amount2_0_0_, account0_.name as name3_0_0_ from account account0_ where account0_.id=? INFO | com.softeem.CqrsDemo3ApplicationTests : Optional[Account{id=1, name='tommy', amount=1000.0}] @CachePut @CachePut 与 @Cacheable 类似。相同点在于: 被标注了 @CachePut 的方法的返回的结果会被缓存。这和 @Cacheable 是一致的。 不同点在于： @CachePut 标注的方法没有从缓存中取数据的环节/功能 。 简单来说，@CachePut 标注的方法只会向缓存中存数据，而从不从缓存中取数据。 @CachePut 也是有 value、key、condition 三个属性，功能和使用方式和 @Cacheable 一致。 @CacheEvict @CacheEvict 注解标注于删除和修改方法上。 被标注了 @CacheEvict 注解的方法在执行结束后，Spring Cache 会删除该注解指定的缓存中的键值对。 @CacheEvict 可以指定的属性有 value、key、condition、allEntries 和 beforeInvocation，其中 value、key 和 condition 的语义与 @Cacheable 对应的属性类似。即 value 表示清除操作是发生在哪些 Cache 上的（对应 Cache 的名称）； key 表示需要清除的是哪个 key，如未指定则会使用默认策略生成的 key； condition 表示清除操作发生的条件。 allEntries 属性 allEntries 是 boolean 类型，表示是否需要清除缓存中的所有元素，默认为 false，表示不需要。当指定了 allEntries 为 true 时，Spring Cache 将忽略指定的 key，删除 value 指定的缓存中的所有键值对。 beforeInvocation 属性 清除操作默认是在对应方法成功执行之后触发的，那么这就导致这样的一个情况：方法如果因为抛出异常结束，而非正常结束，那么就不会触发清除操作 。 使用 beforeInvocation 可以改变触发清除操作的时间，当我们指定该属性值为 true 时，Spring 会在 调用该方法之前清除缓存中的指定元素。 @RequestMapping(\"/beforeInvocation\") @CacheEvict(value=\"usersCache\", allEntries=true, beforeInvocation=true) public void beforeInvocation() { throw new RuntimeException(\"test beforeInvocation\"); } SpEL 上下文数据 Spring Cache 提供了一些供我们使用的 SpEL 上下文数据，下表直接摘自 Spring 官方文档： @Caching 有时候我们可能组合多个 Cache 注解使用；比如用户新增成功后，我们要添加 id-user 键值对，添加 username-user 键值对，添加 email-user 键值对。此时就需要 @Caching 组合多个注解标签了。 @Caching( put = { @CachePut(value = \"user\", key = \"#user.id\"), @CachePut(value = \"user\", key = \"#user.username\"), @CachePut(value = \"user\", key = \"#user.email\") } ) public User save(User user) { ... } 从 @Caching 注解源码可以看出，除了 @Caching - @CachePut 这种组合使用之外，它也可以结合 @Cacheable 和 @CacheEvict 使用： @Caching( put = { @CachePut( ... ), @CachePut( ... ), @CachePut( ... ) } ) @Caching( cacheable = { @Cacheable( ... ), @Cacheable( ... ), @Cacheable( ... ) } ) @Caching( evict = { @CacheEvict( ... ), @CacheEvict( ... ), @CacheEvict( ... ) } ) "},"Part-II/spring-boot/11-spring-boot-quartz.html":{"url":"Part-II/spring-boot/11-spring-boot-quartz.html","title":"Spring Boot 集成 quartz","keywords":"","body":"SpringBoot 集成 Quartz 在项目开发中，经常需要定时任务来帮助我们来做一些内容，比如定时派息、跑批对账、业务监控等。 SpringBoot 体系中现在有两种方案可以选择： 第一种是 SpringBoot 内置的方式简单注解就可以使用 如果需要更复杂的应用场景可以使用 Quartz Quartz 目前是 Java 体系中最完善的定时方案。 SpringBoot 内置定时 pom 包配置 pom 包里面只需要引入 SpringBoot Starter 包即可，SpringBoot Starter 包中已经内置了定时的方法。 org.springframework.boot spring-boot-starter 启动类开启定时 在启动类上面加上 @EnableScheduling 即可开启定时: @Spring BootApplication @EnableScheduling public class Application { public static void main(String[] args) { SpringApplication.run(Application.class， args); } } 创建定时任务实现类 使用 SpringBoot 自带的定时非常的简单，只需要在方法上面添加 @Scheduled 注解即可。 定时任务1: @Component public class SchedulerTask { private int count=0; @Scheduled(cron=\"*/6 * * * * ?\") private void process(){ System.out.println(\"this is scheduler task runing \" + (count++)); } } 设置 process() 每隔六秒执行一次，并统计执行的次数。 我们还有另外的一种方案来设置，固定时间周期执行方法。 定时任务2: @Component public class Scheduler2Task { private static final SimpleDateFormat dateFormat = new SimpleDateFormat(\"HH:mm:ss\"); @Scheduled(fixedRate = 6000) public void reportCurrentTime() { System.out.println(\"现在时间:\" + dateFormat.format(new Date())); } } 启动项目之后，就会在控制台看到打印的结果。 结果如下: this is scheduler 现在时间:09:44:17 this is scheduler 现在时间:09:44:23 this is scheduler 现在时间:09:44:29 this is scheduler 现在时间:09:44:35 task runing 0 task runing 1 task runing 2 task runing 3 说明两个方法都按照固定 6 秒的频率来执行。 参数说明 @Scheduled 参数可以接受两种定时的设置，一种是我们常用的 cron=\"*/6 * * * * ?\"，一种是 fixedRate = 6000，两种都可表示固定周期执行定时任务。 fixedRate 说明 @Scheduled(fixedRate = 6000):上一次开始执行时间点之后 6 秒再执行。 @Scheduled(fixedDelay = 6000):上一次执行完毕时间点之后 6 秒再执行。 @Scheduled(initialDelay=1000， fixedRate=6000):第一次延迟 1 秒后执行，之后按 fixedRate 的规则每 6 秒执行一次。 cron 说明 cron 一共有七位，最后一位是年，SpringBoot 定时方案中只需要设置六位即可: 第一位，表示秒，取值 0 ~ 59; 第二位，表示分，取值 0 ~ 59; 第三位，表示小时，取值 0 ~ 23; 第四位，日期天/日，取值 1 ~ 31; 第五位，日期月份，取值 1~12; 第六位，星期，取值 1 ~ 7，星期一，星期二...，注，不是第 1 周、第 2 周的意思，另外，1 表示星期天，2 表示星期一; 第七位，年份，可以留空，取值 1970 ~ 2099。 cron 中，还有一些特殊的符号，含义如下: (*) 星号 可以理解为每的意思，每秒、每分、每天、每月、每年 ... 。 (?) 问号 问号只能出现在日期和星期这两个位置，表示这个位置的值不确定，每天 3 点执行，因此第六位星期的位置，是不需要关注的，就是不确定的值;同时，日期和星期是两个相互排斥的元素，通过问号来表明不指定值，比如 1 月 10 日是星期一，如果在星期的位置另指定星期二，就前后冲突矛矛盾了。 (-) 减号 表达一个范围，如在小时字段中使用“10 ~ 12”，则表示从 10 到 12 点，即 10、11、12。 (,) 逗号 表达一个列表值，如在星期字段中使用“1、2、4”，则表示星期一、星期二、星期四。 (/) 斜杠 如 x/y，x 是开始值，y 是步长，比如在第一位(秒)，0/15 就是从 0 秒开始，每隔 15 秒执行一次，最后就是 0、15、30、45、60，另 */y，等同于 0/y 。 下面列举几个常用的例子子。 实例 说明 0 0 3 * * ? 每天 3 点执行 0 5 3 * * ? 每天 3 点 5 分执行 0 5 3 ? * * 每天 3 点 5 分执行，与上面作用相同 0 5/10 3 * * ? 每天 3 点的 5 分、15 分、25 分、35 分、45 分、55 分这几个时间点执行 0 10 3 ? * 1 每周星期天，3 点 10 分执行，注，1 表示星期天 0 10 3 ? * 1#3 每个月的第三个星期，星期天执行，# 号只能出现在星期的位置 Quartz Quartz 是一个开源的作业调度框架，它完全由 Java 写成，提供了巨大的灵活性而不牺牲简单性。 当定时任务愈加复杂时，使用 Spring 注解 @Schedule 已经不能满足业务需要。 Quartz 的优点: 丰富的 Job 操作 API; 支持多种配置; SpringBoot 无缝集成; 支持久化; 支持集群; Quartz 还支持开源，是一个功能丰富的开源作业调度库，可以集成到几乎任何 Java 应用程序中。 Quartz 体系结构 Quartz 有 4 个核心概念：Job(任务)、JobDetail(任务信息)、Trigger(触发器)和 Scheduler(调度器)。 Job 是一个接口，只定义一个方法 execute(JobExecutionContext context)，在实现接口的 execute 方法中编写所需要定时执行的 Job(任务)，JobExecutionContext 类提供了调度应用的一些信息; Job 运行时的信息保存在 JobDataMap 实例中。 JobDetail Quartz 每次调度 Job 时，都重新创建一个 Job 实例，因此它不接受一个 Job 的实例，相反它接收一个 Job 实现类(JobDetail，描述 Job 的实现类及其他相关的静态信息，如 Job 名字、描述、关联监听器等信息)，以便运行时通过 newInstance() 的反射机制实例化 Job。 Trigger 是一个类，描述触发 Job 执行的时间触发规则，主要有 SimpleTrigger 和 CronTrigger 这两个子类。当且仅当需调度一次或者以固定时间间隔周期执行调度，SimpleTrigger 是最适合的选择;而 CronTrigger 则可以通过 Cron 表达式定义出各种复杂时间规则的调度方案:如工作日周一到周五的 15:00 ~ 16:00 执行调度等。 Scheduler 调度器就相当于一个容器，装载着任务和触发器，该类是一个接口，代表一个 Quartz 的独立运行容器，Trigger 和 JobDetail 可以注册到 Scheduler 中，两者在 Scheduler 中拥有各自的组及名称，组及名称是 Scheduler 查找定位容器中某一对象的依据，Trigger 的组及名称必须唯一，JobDetail 的组和名称也必须唯一(但可以和 Trigger 的组和名称相同，因为它们是不同类型的)。Scheduler 定义了多个接口方法，允许外部通过组及名称访问和控制容器中 Trigger 和 JobDetail。 四者其关系如下图所示: Job 为作业的接口，为任务调度的对象; JobDetail 用来描述 Job 的实现类及其他相关的静态信息; Trigger 做为作业的定时管理工具，一个 Trigger 只能对应一个作业实例，而而一个作业实例可对应多个触发器; Scheduler 做为定时任务容器器，是 Quartz 最上层的东西，它提携了所有触发器和作业，使它们协调工作，每个 Scheduler 都存有 JobDetail 和 Trigger 的注册，一个 Scheduler 中可以注册多个 JobDetail 和多个 Trigger。 SpringBoot 和 Quartz SpringBoot 2.0 提供了 spring-boot-starter-quartz 组件集成 Quartz，让我们在项目中使用 Quartz 变得简单。 配置 pom.xml 添加 spring-boot-starter-quartz 组件: org.springframework.boot spring-boot-starter-quartz 简单示例 配置完成之后先来做一个最简单的示例，使用 Quartz 定时输出 Hello World 。 首先定义一个 Job 需要继承 QuartzJobBean，示例中 Job 定义一个变量 Name，用于在定时执行的时候传入。 public class SampleJob extends QuartzJobBean { private String name; public void setName(String name) { this.name = name; } @Override protected void executeInternal(JobExecutionContext context) throws JobExecutionException { System.out.println(String.format(\"Hello %s!\"， this.name)); } } 接下来构建 JobDetail，并且构建时传入 name 属性的值，构建 JobTrigger 和 scheduleBuilder，最后使用 Scheduler 启动定时任务。 @Configuration public class SampleScheduler { @Bean public JobDetail sampleJobDetail() { return JobBuilder .newJob(SampleJob.class) .withIdentity(\"sampleJob\") .usingJobData(\"name\"， \"World\") .storeDurably() .build(); } @Bean public Trigger sampleJobTrigger() { SimpleScheduleBuilder scheduleBuilder = SimpleScheduleBuilder .simpleSchedule() .withIntervalInSeconds(2) .repeatForever(); return TriggerBuilder.newTrigger() .forJob(sampleJobDetail()) .withIdentity(\"sampleTrigger\") .withSchedule(scheduleBuilder) .build(); } } JobBuilder 无构造函数，只能通过 JobBuilder 的静态方法 newJob(Class jobClass) 生成 JobBuilder 实例。 withIdentity 方法可以传入两个参数 withIdentity(String name，String group) 来定义 TriggerKey，也可以不设置，像上文示例中会自动生成一个独一无二的 TriggerKey 用来区分不同的 Trigger。 启动项目后每隔两秒输出:Hello World! Hello World! Hello World! Hello World! ... CronSchedule 示例 CronSchedule 可以设置更灵活的使用方式，定时设置可以参考上面的 cron 表达式。 首先定义两个 Job: public class ScheduledJob implements Job { @Override public void execute(JobExecutionContext context) throws JobExecutionException { System.out.println(\"schedule job1 is running ...\"); } } ScheduledJob2 和 ScheduledJob 代码基本一致。 按照使用 Quartz 的逻辑，构建 jobDetail、CronTrigger，最后使用 scheduler 关联 jobDetail 和 CronTrigger。scheduleJob1 设置每间隔 6 秒执行一次。 private void scheduleJob1(Scheduler scheduler) throws SchedulerException{ JobDetail jobDetail = JobBuilder .newJob(ScheduledJob.class) .withIdentity(\"job1\"， \"group1\") .build(); CronScheduleBuilder scheduleBuilder = CronScheduleBuilder .cronSchedule(\"0/6 * * * * ?\"); CronTrigger cronTrigger = TriggerBuilder .newTrigger() .withIdentity(\"trigger1\"， \"group1\") .withSchedule(scheduleBuilder) .build(); scheduler.scheduleJob(jobDetail，cronTrigger); } CronScheduleBuilder.cronSchedule(\"0/6 ?\")，按照 cron 表达式设置定时任务的执行周期。 ScheduleJob2 的内容和 ScheduleJob1 基本一致，时间设置为间隔 12 秒执行一次。 使用 Scheduler 启动两个定时任务。 public void scheduleJobs() throws SchedulerException { Scheduler scheduler = schedulerFactoryBean.getScheduler(); scheduleJob1(scheduler); scheduleJob2(scheduler); } 何时触发定时任务 我们有两种方案来触发 CronSchedule 定时任务，一种是启动时调用 scheduleJobs() 来启动定时任务，另外一种方案使用 SpringBoot 自带的 Scheduled 在特定时间触发启动。 第一种方方案，启动时触发定时任务: @Component public class MyStartupRunner implements CommandLineRunner { @Autowired public CronSchedulerJob scheduleJobs; @Override public void run(String... args) throws Exception { scheduleJobs.scheduleJobs(); System.out.println(\">>>> 定时任务开始执行 定时一个 Runner，继承 CommandLineRunner 并重新 run 方法，在 run 方方法中调用 scheduleJobs() 来启动定时任务。 第二种方案，特定时间启动定时任务: @Configuration @EnableScheduling @Component public class SchedulerListener { @Autowired public CronSchedulerJob scheduleJobs; @Scheduled(cron=\"0 30 11 25 11 ?\") public void schedule() throws SchedulerException { scheduleJobs.scheduleJobs(); } } 启动项目后每隔 6 秒输出 job1 内容，每隔 12 秒输出 job2 内容，再加上面示例每两秒输出的 Hello World，输出内容如下: Hello World! Hello World! Hello World! schedule job1 is running ... Hello World! Hello World! Hello World! schedule job1 is running ... schedule job2 is running ... ... 一般情况下，建议使用第一种方案来启动定时任务;第二种方案设置固定日期时，需要考虑重复启动定时任务的情况，重复启动定时任务会报错。 注意，两种启动方案，在项目中选择一种使用即可，否则会导致重复启动定时任务而报错。 "},"Part-II/spring-boot/12-spring-boot-mail.html":{"url":"Part-II/spring-boot/12-spring-boot-mail.html","title":"Spring Boot 开发邮件系统","keywords":"","body":"使用 Spring Boot 开发邮件系统 邮件发送流程 发信人在用户代理上编辑邮件，并写清楚收件人的邮箱地址; 用户代理根据发信人编辑的信息，生成一封符合邮件格式的邮件; 用户代理把邮件发送到发信人的邮件服务器上，邮件服务器上面有一个缓冲队列列，发送到邮件服务器上面的邮件都会加入到缓冲队列中，等待邮件服务器上的 SMTP 客户端进行行发送; 发信人的邮件服务器使用 SMTP 协议把这封邮件发送到收件人的邮件服务器上; 收件人的邮件服务器收到邮件后，把这封邮件放到收件人在这个服务器上的信箱中; 收件人使用用户代理来收取邮件，首先用户代理使用 POP3 协议来连接收件人人所在的邮件服务器，身份验证成功后，用户代理就可以把邮件服务器上面的收件人人邮箱里面的邮件读取出来，并展示给收件人。 这就是邮件发送的一个完整流程。 简单来说，邮件的接收发送类似 Git 中的 push 和 pull，是分开的两个操作。并且 push 和 pull 使用的是不同的协议：push 使用的是 SMTP 协议；pull 使用的是 POP3 协议。 简单使用 最早期的时候使用 JavaMail 的相关 API 来开发，需要自己去封装消息体，代码量比较庞大;后来 Spring 推出了 JavaMailSender 来简化邮件发送过程，JavaMailSender 提供了强大的邮件发送功能，可支持各种类型的邮件发送。 现在 Spring Boot 在 JavaMailSender 的基础上又进行了封装，就有了现在的 spring-boot-starter-mail，让邮件发送流程更加简洁和完善。 pom 包配置 org.springframework.boot spring-boot-starter-mail 配置文件 在 application.properties 中添加邮箱配置，不同的邮箱参数稍有不同，下面面列举几个常用邮箱配置。 163 邮箱配置 spring.mail.host=smtp.163.com // 邮箱服务器器地址 spring.mail.username=xxx@oo.com // 用用户名 spring.mail.password=xxx // 密码 spring.mail.default-encoding=UTF-8 // 超时时间，可选 spring.mail.properties.mail.smtp.connectiontimeout=5000 spring.mail.properties.mail.smtp.timeout=3000 spring.mail.properties.mail.smtp.writetimeout=5000 126 邮箱配置 spring.mail.host=smtp.126.com spring.mail.username=xxx@126.com spring.mail.password=xxx spring.mail.default-encoding=UTF-8 QQ 邮箱配置如下: spring.mail.host=smtp.qq.com spring.mail.username=xxx@qq.com spring.mail.password=xxx spring.mail.default-encoding=UTF-8 注意:测试时需要将 spring.mail.username 和 spring.mail.password 改成自自己邮箱对应的登录名和密码，这里的密码不是邮箱的登录密码，是开启 POP3 之后设置的客户端授权密码。 这里以 126 邮件举例，有两个地方需要在邮箱中设置。 开启 POP 3 / SMTP 服务、IMAP / SMTP 服务 图片下方会有 SMTP 等相关信息的配置提示。 开通设置客户端授权密码 设置客户端授权密码一般需求手机验证码验证。 文本邮件发送 Spring 已经帮我们内置了 JavaMailSender，直接在项目中引用即可，封装一个 MailService 类来实现普通的邮件发送方法。 @Component public class MailServiceImpl implements MailService { private final Logger logger = LoggerFactory.getLogger(this.getClass()); @Autowired private JavaMailSender mailSender; @Value(\"${spring.mail.username}\") private String from; @Override public void sendSimpleMail(String to, String subject, String content) { SimpleMailMessage message = new SimpleMailMessage(); message.setFrom(from); message.setTo(to); message.setSubject(subject); message.setText(content); try { mailSender.send(message); logger.info(\"简单邮件已经发送。\"); } catch (Exception e) { logger.error(\"发送简单邮件时发生生异常!\", e); } } } 文本邮件抄送使用:message.copyTo(copyTo) 来实现。 from，即为邮件发送者，一般设置在配置文件中 to，邮件接收者，此参数可以为数组，同时发送多人 subject，邮件主题 content，邮件的主体 邮件发送者 from 一般采用固定的形式写到配置文件中。 编写 test 类进行测试 @RunWith(SpringRunner.class) @Spring BootTest public class MailServiceTest { @Autowired private MailService MailService; @Test public void testSimpleMail() throws Exception { mailService.sendSimpleMail(\"hemiao3000@126.com\", \"这是一封简单邮件\", \"大家好，这是我的第一封邮件!\"); } } 稍微等待几秒，就可以在邮箱中找到此邮件内容了。 富文本邮件 在日常使用的过程中,我们通常在邮件中加入图片或者附件来丰富邮件的内容。 发送 HTML 格式邮件 邮件发送支持以 HTML 语法去构建自定义的邮件格式,Spring Boot 支持使用用 HTML 发送邮件。 我们在 MailService 中添加支持 HTML 邮件发送的方法: public void sendHtmlMail(String to, String subject, String content) { MimeMessage message = mailSender.createMimeMessage(); try { // true 表示需要创建一一个 multipart message MimeMessageHelper helper = new MimeMessageHelper(message, true); helper.setFrom(from); helper.setTo(to); helper.setSubject(subject); helper.setText(content, true); mailSender.send(message); logger.info(\"html邮件发送成功\"); } catch (MessagingException e) { logger.error(\"发送html邮件时发生生异常!\", e); } } 富文本邮件抄送使用:helper.addCc(cc) 来实现。 和文本邮件发送代码对比,富文本邮件发送使用 MimeMessageHelper 类,该类支持发送复杂邮件模板,支持文本、附件、HTML、图片等。 在测试类中构建 HTML 内容,测试发送: @Test public void testHtmlMail() throws Exception { String content = \"\\n\" + \"\\n\" + \"hello world ! 这是一一封html邮件!\\n\" + \"\\n\" + \"\"; mailService.sendHtmlMail(\"hemiao3000@126.com\",\"这是一封HTML邮件\", content); } 代码中拼接出的 HTML 的 String 字符串交给 MimeMessageHelper 来处理理,最后由邮件客户端负责渲染显示内容。 发送带附件的邮件 在 MailService 添加 sendAttachmentsMail 方法,发送带附件的邮件主要是使用 FileSystemResource 对文件进行封装,再添加到 MimeMessageHelper 中。 public void sendAttachmentsMail ( String to, String subject, String content, String filePath) { MimeMessage message = mailSender.createMimeMessage(); try { MimeMessageHelper helper = new MimeMessageHelper(message, true); helper.setFrom(from); helper.setTo(to); helper.setSubject(subject); helper.setText(content, true); FileSystemResource file = new FileSystemResource(new File(filePath)); String fileName = file.getFilename(); helper.addAttachment(fileName, file); // helper.addAttachment(\"test\"+fileName, file); mailSender.send(message); logger.info(\"带附件的邮件已经发送。\"); } catch (MessagingException e) { logger.error(\"发送带附件的邮件时发生生异常!\", e); } } 添加多个附件可以使用多条 helper.addAttachment(fileName, file) 。 在测试类中添加测试方法: @Test public void sendAttachmentsMail() { String filePath = \"e:\\\\temp\\\\fastdfs-client-java-5.0.0.jar\"; mailService.sendAttachmentsMail(\"hemiao3000@126.com\", \"主题:带附件的邮件\", \"有附件,请查收!\", filePath); } 附件可以是图片、压缩包、Word 等任何文件,但是邮件厂商一般都会对附件大小有限制,太大的附件建议使用网盘上传后,在邮件中给出链接。 发送带静态资源的邮件 邮件中的静态资源一般指图片,在 MailService 中添加 sendInlineResourceMail 方法: public void sendInlineResourceMail( String to, String subject, String content, String rscPath, String rscId) { MimeMessage message = mailSender.createMimeMessage(); try { MimeMessageHelper helper = new MimeMessageHelper(message, true); helper.setFrom(from); helper.setTo(to); helper.setSubject(subject); helper.setText(content, true); FileSystemResource res = new FileSystemResource(new File(rscPath)); helper.addInline(rscId, res); mailSender.send(message); logger.info(\"嵌入静态资源的邮件已经发送。\"); } catch (MessagingException e) { logger.error(\"发送嵌入静态资源的邮件时发生异常!\", e); } } 在测试类中添加测试方法: @Test public void sendInlineResourceMail() { String rscId = \"neo006\"; String content = \"这是有图片片的邮件:\"; String imgPath = \"e:\\\\temp\\\\weixin.jpg\"; mailService.sendInlineResourceMail(\"hemiao3000@126.com\", \"主题:这是有图片的邮件\", content, imgPath, rscId); } 添加多个图片可以使用多条 和 helper.addInline(rscId, res) 来实现。 "},"Part-II/spring-boot/13-spring-boot-swagger.html":{"url":"Part-II/spring-boot/13-spring-boot-swagger.html","title":"Spring Boot 中使用 Swagger","keywords":"","body":"Swagger 什么是 Swagger Swagger 是一系列 RESTful API 的工具，通过 Swagger 可以获得项目的⼀种交互式文档，客户端 SDK 的⾃ 动生成等功能。 Swagger 的目标是为 REST APIs 定义一个标准的、与语⾔言无关的接口，使人和计算机在看不到源码或者看不到文档或者不能通过网络流量检测的情况下，能发现和理解各种服务的功能。当服务通过 Swagger 定义，消费者就能与远程的服务互动通过少量的实现逻辑。 Swagger（丝袜哥）是世界上最流行的 API 表达工具。 快速上手 使用 Spring Boot 集成 Swagger 的理念是，使⽤用注解来标记出需要在 API 文档中展示的信息，Swagger 会根据项目中标记的注解来生成对应的 API 文档。Swagger 被号称世界上最流行的 API 工具，它提供了 API 管理的全套解决方案，API 文档管理需要考虑的因素基本都包含，这里将讲解最常用的定制内容。 Spring Boot 集成 Swagger 2.X 很简单，需要引入依赖并做基础配置即可。 io.springfox springfox-swagger2 2.8.0 io.springfox springfox-swagger-ui 2.8.0 创建 SwaggerConfig 配置类 @Configuration @EnableSwagger2 public class SwaggerConfig { } 在 SwaggerConfig 的类上添加两个注解： 注解 说明 @Configuration 启动时加载此类 @EnableSwagger2 表示此项目启用 Swagger API 文档功能 在 SwaggerConfig 中添加两个方法：（其中一个方法是为另一个方法作辅助的准备工作） @Bean public Docket api() { return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) .select() // 此处自行修改为自己的 Controller 包路径。 .apis(RequestHandlerSelectors.basePackage(\"xxx.yyy.zzz\")) .paths(PathSelectors.any()) .build(); } 此方法使用 @Bean，在启动时初始化，返回实例 Docket（Swagger API 摘要对象），这里需要注意的是 .apis(RequestHandlerSelectors.basePackage(\"xxx.yyy.zzz\")) 指定需要扫描的包路路径，只有此路径下的 Controller 类才会自动生成 Swagger API 文档。 private ApiInfo apiInfo() { return new ApiInfoBuilder() .title(\"XXX 项目接口文挡\") .description(\"XXX Project Swagger2 UserService Interface\") .termsOfServiceUrl(\"http://www.163.com\") .version(\"1.0\") .build(); } 这块配置相对重要一些，主要配置页面展示的基本信息包括，标题、描述、版本、服务条款等，查看 ApiInfo 类的源码还会发现支持 license 等更多的配置。 配置完成之后启动项目，在浏览器中输入网址 http://localhost:8080/swagger-ui.html，即可看到上面的配置信息，效果如下： Swagger 常用注解 Swagger 通过注解表明该接口会生成文档，包括接口名、请求方法、参数、返回信息等，常用注解内容如下： 作用范围 API 使⽤用位置 协议集描述 @Api 用于 Controller 类上 协议描述 @ApiOperation 用在 Controller 的方法上 非对象参数集 @ApiImplicitParams 用在 Controller 的方法上 非对象参数描述 @ApiImplicitParam 用在 @ApiImplicitParams 的方法里边 响应集 @ApiResponses 用在 Controller 的方法上 响应信息参数 @ApiResponse 用在 @ApiResponses 里边 描述返回对象的意义 @ApiModel 用在返回对象类上 对象属性 @ApiModelProperty 用在出入参数对象的字段上 例如： @Api(value = \"用户服务\", description = \"用户操作 API\") @RestController @RequestMapping(\"/user\") public class UserController { @ApiOperation(value = \"获取用户信息\", notes = \"根据id在取用户信息\", produces = \"application/json\", response = Result.class) @ApiImplicitParams({ @ApiImplicitParam(name = \"id\", value = \"用户Id\", required = true, dataType = \"int\", paramType = \"path\") }) @GetMapping(value = \"/{id}\") public Result getUser(@PathVariable int id) { System.out.println(id); return new Result(ResultCode.OK, new DomainUser()); } } "},"Part-I/Gist/jdbc.properties.html":{"url":"Part-I/Gist/jdbc.properties.html","title":"jdbc.properties","keywords":"","body":"jdbc.properties jdbc .properties 和命令行类似，原则上一行就是一个键值对，如果因为值太长需要折行继续编写，那么上一行的行尾需要加 \\ 表示本行还未结束 。 !FILENAME jdbc.properties datasource.driver-class-name=com.mysql.cj.jdbc.Driver datasource.url=jdbc:mysql://127.0.0.1:3306/scott\\ ?useUnicode=true\\ &characterEncoding=utf-8\\ &useSSL=true\\ &serverTimezone=UTC datasource.username=root datasource.password=123456 "},"Part-I/Gist/logback.xml.html":{"url":"Part-I/Gist/logback.xml.html","title":"logback.xml","keywords":"","body":"logback.xml logback.xml 1.0 !FILENAME 简单的例子 %5p --- %-40.40logger{39} : %m%n utf8 logback.xml 2.0 !FILENAME 更复杂的例子 %d{yyyy-MM-dd HH:mm:ss} %5p ---- %-40.40logger{39} : %m%n utf8 %d{yyyy-MM-dd HH:mm:ss.SSS} %5p ---- [%15.15t] %-40.40logger{39} : %m%n utf8 ${LOG_FILE} ${LOG_FILE}.%d{yyyy-MM-dd}.%i.gz 10MB 0 的关联关系 --> "},"Part-I/Gist/pom.xml.html":{"url":"Part-I/Gist/pom.xml.html","title":"pom.xml","keywords":"","body":"pom.xml 文件模板 版本信息来源说明 以下的版本信息截取自 spring-boot-starter 2.0.9 和 mybatis-spring-boot 2.0.1 。 spring-boot-starter 2.0.9 是 spring cloud Finchley.SR4（ Apr, 2019）使用的版本； mybatis-spring-boot 2.0.1 最低支持的 spring boot 版本刚好最低也是支持 2.0.9 。 几个『高版』本的注意事项： lombok 的高版本依赖于 JDK 9，因此版本不要过高。（1.6 和 1.8 版本出现过这种情况）。 hibernate-validator 的高版本（邮箱注解）依赖于高版本的 el-api，tomcat 8 的 el-api 是 3.0 满足需要，但是 tomcat 7 的 el-api 只有 2.2，不满足其要求。 mysql-connector-java 高版本（6 及以上）有两处变动: 驱动类变为：com.mysql.cj.jdbc.Driver，多了个 cj url 中需要明确指定 serverTimezone，例如：...&serverTimezone=UTC properties 1.0 !FILENAME pom 的 properties 部分 UTF-8 1.8 1.8 1.14.8 1.7.26 1.2.3 3.7 5.0.13.RELEASE 1.8.14 3.1.0 2.2 1.2 2.9.8 5.4.3.Final 5.1.47 2.7.9 3.5.1 2.0.1 5.1.8 5.2.18.Final 1.0.2.Final 2.0.1 5.15.9 5.4.3 2.0.12.RELEASE 5.0.12.RELEASE 4.12 1.4.199 dependencies 1.0 SSM logback + lombok + jackson + hibernate-validator hikaricp + mybatis-pagehelper !FILENAME dependencies和build/plugins部分 org.projectlombok lombok ${lombok.version} ch.qos.logback logback-classic ${logback.version} org.apache.commons commons-lang3 ${commons-lang3.version} org.aspectj aspectjweaver ${aspectj.version} com.fasterxml.jackson.core jackson-databind ${jackson.version} org.springframework spring-webmvc ${spring.version} javax.servlet javax.servlet-api ${servlet-api.version} provided javax.servlet.jsp jsp-api ${jsp-api.version} provided javax.servlet jstl ${jstl.version} org.hibernate hibernate-validator ${hibernate-validator.version} org.springframework spring-jdbc ${spring.version} com.zaxxer HikariCP ${hikaricp.version} mysql mysql-connector-java ${mysql.version} org.mybatis mybatis-spring ${mybatis-spring.version} org.mybatis mybatis ${mybatis.version} com.github.pagehelper pagehelper ${pagehelper.version} org.springframework spring-test ${spring.version} test junit junit ${junit.version} test ${project.artifactId} src/main/java **/*.xml **/*.properties src/main/resources org.apache.tomcat.maven tomcat7-maven-plugin 2.2 8080 /${project.artifactId} UTF-8 dependencies 2.0 spring-mvc + mysql-driver + hikaricp org.springframework spring-webmvc ${spring.version} javax.servlet javax.servlet-api ${servlet-api.version} provided javax.servlet.jsp jsp-api ${jsp-api.version} provided javax.servlet jstl ${jstl.version} org.hibernate hibernate-validator ${hibernate-validator.version} mysql mysql-connector-java ${mysql.version} com.zaxxer HikariCP ${hikaricp.version} ${project.artifactId} org.apache.tomcat.maven tomcat7-maven-plugin 2.2 /${project.artifactId} 8080 UTF-8 settings.xml /path/to/local/repo --> nexus-aliyun Nexus aliyun * http://maven.aliyun.com/nexus/content/groups/public jdk-1.8 true 1.8 1.8 1.8 1.8 "},"Part-I/Gist/web.xml.html":{"url":"Part-I/Gist/web.xml.html","title":"web.xml","keywords":"","body":"web.xml 文件模板 web.xml web.xml 只利用一次加载时机 Archetype Created Web Application HelloWeb org.springframework.web.servlet.DispatcherServlet contextConfigLocation classpath:application-context.xml 1 HelloWeb *.do web.xml 3.0 利用两次加载时机 Archetype Created Web Application org.springframework.web.context.ContextLoaderListener contextConfigLocation classpath:spring/spring-service.xml, classpath:spring/spring-dao.xml HelloWeb org.springframework.web.servlet.DispatcherServlet contextConfigLocation classpath:spring/spring-web.xml 1 HelloWeb *.do web.xml 4.0 启用 Spring MVC 自带的 POST 请求编码过滤器，解决中文乱码问题。 "},"Part-I/Gist/mybatis-config.xml.html":{"url":"Part-I/Gist/mybatis-config.xml.html","title":"mybatis-config.xml","keywords":"","body":"mybatis-config.xml mybatis-config.xml 1.0 none mybatis-config.xml 2.0 none mybatis-config.xml 3.0 SSM 整合时使用，开启 id 主键回填功能。 "},"Part-I/Gist/spring-dao.xml.html":{"url":"Part-I/Gist/spring-dao.xml.html","title":"spring-dao.xml","keywords":"","body":"spring-dao.xml for Myabtis 默认 Spring 的项目中只能出现一个 context:property-placeholder，你如果想加载多个配置文件，可以在一个配置文件中写多个文件路径名： 另一种办法是下面这样，通过为每一个 placeholder 指定 ignore-unresolvable=\"true\" 让 spring 支持多个 placeholder 。 "},"Part-I/Gist/spring-service.xml.html":{"url":"Part-I/Gist/spring-service.xml.html","title":"spring-service.xml","keywords":"","body":"spring-service.xml for Mybatis for JPA 注意，JPA 的事务管理器和 Mybatis 的事务管理器不一样，不要随便复制粘贴 。其他的部分一样。 "},"Part-I/Gist/spring-web.xml.html":{"url":"Part-I/Gist/spring-web.xml.html","title":"spring-web.xml","keywords":"","body":"spring-web.xml 文件模板 spring-web.xml !FILENAME spring-web.xml "},"Part-I/Gist/dependencies.spring-boot-2.0.9.html":{"url":"Part-I/Gist/dependencies.spring-boot-2.0.9.html","title":"Spring Boot 2.0.9 版本","keywords":"","body":" 5.15.9 2.7.7 1.9.73 2.4.0 1.8.14 3.9.1 4.0.6 2.1.4 3.0.0 1.7.11 2.6.2 3.4.0 1.3.4 1.11 2.2.0 3.7 1.6 2.5.0 2.1.0 2.5.9 10.14.2.0 1.6.1 3.2.6 2.10.6 3.5.3 5.6.16 2.0.3 1.5.0 1.0.1 5.0.7 2.3.28 2.2.6 3.0.0 2.4.16 2.8.5 1.4.199 1.3 3.9.4 1.2.3 5.2.18.Final 1.0.2.Final 6.0.16.Final 2.7.9 2.4.1 2.29 4.1.4 4.5.8 4.4.11 9.1.7.Final 2.9 2.9.8 3.0.12 1.3.2 1.1.0 2.3.1 2.0.1 1.1.4 1.0 1.6.2 1.0.3 1.2 2.0.1.Final 1.1.6 3.0.5 3.3.2.Final 7.6.0.Final 2.0.6 2.9.3 2.26 5.3.4 9.4.15.v20190215 8.5.35.1 2.2.0.v201112011158 1.14 4.5.2 2.9.9 1.1.11 1.1.11 1.5.0 3.10.8 1.5.0 2.4.0 1.2 1.3.1 4.12 5.1.1 1.1.0 1.0.2 1.2.71 5.0.5.RELEASE 3.5.5 2.10.0 1.2.3 1.16.22 2.2.6 1.8 3.1.1 3.0.0 3.7.0 3.0.2 2.8.2 2.10 3.0.0-M2 2.21.0 2.2 2.5.2 3.1.0 3.0.2 3.0.1 3.0.2 2.4.3 3.6 3.0.1 2.21.0 3.1.0 1.0.10 2.15.0 3.6.4 1.7.1 6.2.2.jre8 5.1.47 5.8.2.Final 1.9.22 3.1.8 4.1.34.Final 1.1.0 42.2.5 2.3.1 4.1.4 5.4.3 1.0.2 Bismuth-SR17 3.0.7 1.3.8 2.1.17 1.2.1 3.9.1 2.29.3 4.1.2 3.1.0 1.1.1 1.7.26 1.19 6.6.6 5.0.13.RELEASE 2.0.12.RELEASE 4.0.3.RELEASE 2.0.5.RELEASE Kay-SR14 0.25.1.RELEASE 5.0.13.RELEASE 2.1.12.RELEASE 2.3.2.RELEASE 1.2.0.RELEASE 2.0.3.RELEASE 1.2.4.RELEASE 5.0.12.RELEASE Apple-SR9 3.0.7.RELEASE 3.21.0.1 3.1.0 1.6.2 3.0.11.RELEASE 2.0.1 3.0.4.RELEASE 3.0.4.RELEASE 3.0.4.RELEASE 2.3.0 8.5.39 4.0.10 1.4.27.Final 2.3 3325375 0.35 1.6.3 1.4.01 1.0.2 2.5.1 "},"Part-I/Gist/dependencies.mybatis-spring-boot-2.0.1.html":{"url":"Part-I/Gist/dependencies.mybatis-spring-boot-2.0.1.html","title":"Mybatis Spring 2.0.1 版本","keywords":"","body":"与 spring-boot 2.0.9 对应 3.5.1 2.0.1 2.0.9.RELEASE "}}