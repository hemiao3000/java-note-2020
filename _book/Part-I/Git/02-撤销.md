<span class="title">删除</span>



# 未添加（Add）前，撤销工作空间中的变更

| 本地改动 | 已 Add | 已 Commit | 撤销 |
| :-: | :-: | :-: | :- |
| Yes | No | No | `git checkout -- <文件名>` |


# 添加（Add）后，未提交（Commit）前，撤销缓存区中的数据

| 本地改动 | 已 Add | 已 Commit | 撤销 |
| :-: | :-: | :-: | :- |
| Yes | Yes | No | `git reset -- <文件名>` |

逻辑上，这相当于 `git add` 操作的 **反向操作**，工作空间上还保留着你对文件的变动。

此时，可以再使用上面的 `git checkout -- <文件名>` 命令来撤销你对工作目录中的文件的修改。

> <small>上述操作可以两步合一步：`git reset --hard`，一口气撤销缓存区和工作空间中的所有变动，工作目录中的内容重新与本地仓库的最新版本保持一致。</small>
>
> <small>注意，这个『硬』撤销操作会让你丢失对文件的修改。慎用。</small>


# 提交（Commit）后的撤销

| 本地改动 | 已 Add | 已 Commit | 撤销 |
| :-: | :-: | :-: | :- |
| Yes | Yes | Yes | `git reset --soft HEAD^1` |

理论上，对文件的变动一旦提交（Commit）后，就无法撤销，毕竟历史记录是不允许篡改的。

Git 可以实现逻辑上的提交后的撤销，即，生成 v5 版本，而 v5 版本的内容与 v3 一致，从而实现使用效果上的撤销，好似从 v4 版本退到了 v3 版本。

此时，Git 本地仓库中的内容『间接恢复』成了 v3 版本的内容，但你的缓存区和工作空间中的内容不受变化。

> <small>如果你之前有 git add 过，缓存区中还是存在这些内容；如果你的工作空间中的文件变更过，变更后的内容还是存在。对于这些数据，你可以有选择性的保留，或舍弃，此时需要你再进行后续操作。</small>

另外，`git reset` 有一种更狠更彻底的撤销：

```
git reset --hard HEAD^1
```

它在上述命令的基础上，会清空你暂存区中的数据，还会用本地版本库中的『最新版本』<small>（逻辑上就是上一个版本）</small>来覆盖你的工作目录。

简单来说，『软』撤销不会动你的本地工作目录和缓存，只动了 本地仓库 `.git` 目录；而『硬』撤销，什么都动。

```bash
git log --graph
```

Git 的每一次提交都会有一个独一无二的标识符。Git 还提供一个叫 `HEAD` 的节点标签，这个节点标签永远代表最新的 `Commit` 。

每一个 Commit 节点都会有一个父节点，HEAD 节点的父节点可以写成 “`HEAD^1`”，可简写成“`HEAD^`”，另一种表示方式为“`HEAD~1`”。

> 注意，当前节点的*爷爷节点* 表示为：“`HEAD~2`”，注意不能写成 “`HEAD^2`”（它表示另一种含义）。

