<span class="title">Spring 中 @transactional 的使用（高级）</span>

# 三大问题

数据库事务的正确执行的 4 个基本要素是 原子性（<font color="dark">**A**</font>tommicity）、一致性（<font color="dark">**C**</font>onsistency）、隔离性（<font color="dark">**I**</font>solation） 和 持久性（<font color="dark">**D**</font>urability）。

| 问题 | 描述 |
| :- | :- |
| 原子性 | 整个事务中的操作，要么全部完成，要么全部不完成，不可能停滞在中间某个环节，仅完成一部分。|
| 一致性 | 指一个事务可以改变数据库状态。食物必须始终保持系统处于一致状态，不管任何给定时间有多少并发事务。 |
| 隔离性 | 指两个事务之间的隔离级别。|
| 持久性 | 在事务完成以后，该事务对数据库所做的更改便持久保存在数据库中，并不会被回滚。|


三大问题从 严重 到 轻度 以此如下：

## 脏读问题

|时刻|事务一（老公）|事务二（老婆）|
|:-:|:-:|:-:|
|T1|查询余额，显示10k|——|
|T2|——|查询余额，显示 10k|
|T3|——|网购 1千，显示 9k|
|T4|请客吃饭开销 1k，显示余额 8k|——|
|T5|提交事务|——|
|T6|——|回滚事务|
|T7|——|最终余额 8k|

所谓脏读，指的就是读到了“脏”数据，即一个事务读取到了另一个事务未提交的数据。


## 不可重复读问题

|时刻|事务一（老公）|事务二（老婆）|
|:-:|:-:|:-:|
|T1|查询余额，显示10k|——|
|T2|——|查询余额，显示 10k|
|T3|——|网购，开销 1k，余额 9k |
|T4|请客吃饭，预计开销 2k|——|
|T5|——|网购，开销 8k，余额 1k|
|T6|——|提交事务|
|T7|吃完买单，显示余额1k，不够付账。|——|

不可重复读，指的是理论上的同一条数据，重复读取，居然会不一样，不具备可重复性。


## 幻读问题

|时刻|事务一（老公）|事务二（老婆）|
|:-:|:-:|:-:|
|T1|——|查询信用卡消费记录，显示 10 条记录|
|T2|网购|——|
|T3|提交事务|——|
|T4|——|打印消费记录，有11条记录|

幻读，和不可重复读类似，第二次读取的数据相较于第一次居然发生了变化，仿佛看到了幻觉。

不可重复读 和 幻读 有一定的相似性，都是指（在本人未改变的情况下）第二次读取的数据，与第一次读取结果不一样。不过它们描述的侧重点（及造成的影响程度）不一样。

- 不可重复读问题，强调的是某一条数据的内容在“我”两次读取间，发生了改变。（因为 update 语句）
- 幻读问题，强调的整个数据的数据总量，在“我”两次读取间，发生了改变。（因为 insert / delete 语句）
- 幻读问题 造成的危害要小于不可重复读问题。


# 四个隔离级别

隔离级别表示：**当“我”操作这张表时，“其他人”对这张表还有多大的操作权限** 。“我”的隔离级别越高，其他人的权利就越小，那么“他”要执行他想要执行的操作而没有权限时，那就只能 <font color="dark">**等**</font>“我”操作完 。

数据库领域有四个隔离级别（注意，这并非 Java 中特有的概念），针对于上述三大问题，四个隔离级别，从 *解决不了任何问题* 到 *解决所有问题*，每一级多解决一个问题。


|隔离级别|解决问题|备注|
|:-:|:-|:-|
|READ_UNCOMMITTED|解决不了任何问题|——|
|READ_COMMITTED|可以解决`脏读`问题|——|
|REPEATABLE_READ|可以解决`不可重复读`问题|<small>包括解决`脏读`问题</small>|
|SERIALIZABLE|解决`幻读`问题|<small>包括解决`不可重复读`和`脏读`问题</small>|


# 传播机制

| 传播行为 | 含义  | 备注 |
| :-----------| :----------- | :- |
| REQUIRED          | 当方法调用时，如果不存在当前事务，那么就创建事务；如果之前已经存在了事物，那么就沿用之前的事务。  | 默认值 |
| SUPPORTS          | 当方法调用时，如果不存在当前事务，就不启用事务；如果当前启用事务，那么就沿用当前事务。           | —— |
| MANATORY          | 方法必须在事务内运行。                                                                | 如果不存在当前事务，则直接抛出异常。|
| REQUIRES_NEW      | 无论是否存在当前事务，方法都会在新的事务中运行                                            | 总是开启一个新事务，执行本方法。|
| NOT_SUPPORTED     | 不支持事务，不存在当前事务也不会创建新事务；如果存在当前事务则挂起它，直到方法结束后才恢复当前事务 | 适用于那些不支持事务的数据库和SQL语句 |
| NEVER             | 不支持事务。                                                                         | MANATORY 的“反面”，如果存在当前事务，就直接抛出异常。|
| NESTED            | 嵌套事务。REQUIRES_NEW 的高级版                                                       | 支持当前事务中使用保存点（savepoint），可以回滚到保存点；如果当前事务没有保存点，则完全等价于 REQUIRES_NEW |

毫无疑问，最常用的是 REQUIRED，其次是 REQUIRES_NEW 。它们是最常见的业务处理方式，其它方式都是用于处理特定的业务。

传播机制本质上描述的是：在一个整体行为中，一个部分行为的失败，会不会对整体行为造成影响，以及造成何种影响。
