
Redis 是目前使用最广泛的缓存中间件，相比 Memcached，Redis 支持更多的数据结构和更丰富的数据操作，而且 Redis 还有着丰富而成熟的集群方案和使用场景。

Redis 是一个速度非常快的非关系数据库（Non-Relational Database），它可以存储键（Key）与 5 种不同类型的值（Value）之间的映射（Mapping），可以将存储在内存的键值对数据持久化到硬盘，可以使用复制特性来扩展读性能，还可以使用客户端分片来扩展写性能。

为了满足高性能，Redis 采用内存（in-memory）数据集，根据使用场景，可以采用两种不同方式来实现数据持久化：

1. 每隔一段时间转存储数据集到磁盘。
2. 追加每条命令到日志中。

持久化也可以被禁用，如果你只是需要一个功能丰富的内存缓存。


# 数据模型

Redis 数据模型不仅仅与关系数据库管理系统（RDBMS）不同，也不同于任何简单的 NoSQL 键-值数据存储系统。

Redis 数据类型类似于编程语言的基础数据类型，因此开发人员感觉很自然，每个数据类型都支持适『用于其类型的操作』，以最大限度发挥每种数据类型的特性。

受支持的数据类型包括：

- string（字符串）
- hash（哈希）
- list（列表）
- set（集合）
- zset（sorted set：有序集合）



# 关键优势

Redis 的优势包括它的速度、对富数据类型的支持、操作的原子性，以及通用性：

- 性能极高，它每秒可执行约 100,000 个 SET 以及约 100,000 个 GET 操作；
- 丰富的数据类型，Redis 对大多数开发人员已知的多数数据类型提供了原生支持，这使得各种问题得以轻松解决；
- 原子性，因为所有 Redis 操作都是原子性的，所以多个客户端会并发地访问一个  Redis 服务器器，获取相同的更新值；
- 丰富的特性，Redis 是一个多效用工具，有非常多的应用场景，包括缓存、消息队列（Redis 原生支持发布/订阅）、短期应用程序数据据（比如 Web 会话）等。



# Redis 的『快』的原因：

1. 是对内存的较为简单的数据进行读写操作。
2. Redis 是 C 语言实现的，它的底层实现原理是基于 IO 多路复用技术。这个实现方案本身就是先进/高级/高效的。
3. Redis 的工作是基于单线程的，从而节省了多线程形式下线程切换的开销。
   1. 一次只运行一条命令，每条命令天生就是一个独立的事务。
   2. 拒绝使用长/慢命令，Redis 对外提供的每条命令都很高效快速。
   3. 其实并不是单线程 <small>有些操作使用独立线程，其它的线程是去干其它的事情，和执行命令的工作线程无关</small>

<small>最后是事实也证明了其作者的最初分析思路是正确的：Redis 的单机性能的瓶颈是网络速度和网卡性能，而非 CPU 。</small>




# Redis 的通用命令

Redis 的常用的基础命令有：

| 命令 | 说明 |
| :- | :- |
| ping | PING 命令来测试客户端与 Redis 的连接是否正常。<br>连接正常时会收到回复 PONG |
| set / get | 使用 set 和 get 可以向 redis 设置数据、获取数据。 |
| del | 删除指定 key 的内容。 |
| Keys  * | 查看当前库中所有的 key 值 |

一个 Redis 实例可以包括多个数据库。不过，一个 redis 实例最多可提供 16 个数据库，而且固定了以下标从 0 到 15 作为数据库名。客户端默认连接第 0 号数据库。

可以通过 `select` 命令来当前数据库：

 > select N

如果选择一个不存在数据库则会报错。


# Redis 单机多实例（了解）

如果需要启动两个 Redis 实例，你可以这么干：

1. 在 Redis 解压目录下创建两个文件夹，例如：*`6379`* 和 *`16379`* 。
2. 将 *`redis.windows.conf`* 文件复制进这两个文件夹，并将 *`16379`* 中的配置文件中的 `port 6379` 改为 `port 16379`。
3. 在这两个文件夹中，分别启动两个命令行，执行 *`../redis-server.exe redis.windows.conf`* 命令。
4. 未来，在使用 *`redis-cli.exe`* 连接 Redis 服务端的时候，就需要明确指定连接端口号。


# 持久化（了解）

Redis 的高性能是由于其将所有数据都存储在了内存中，为了使 Redis 在重启之后仍能保证数据不丢失，需要将数据从内存中同步到硬盘中，这一过程就是持久化。

Redis支持两种方式的持久化，一种是 RDB 方式，一种是 AOF 方式。

## RDB 方式

RDB 方式是 Redis 的默认持久化方式。

它是通过快照（snapshotting）完成的，当符合一定条件时 Redis 会自动将内存中的数据进行快照并持久化到硬盘。简单来说，就是直接将内存中的数据直接保存到硬盘上。

在 *`redis.windows.conf`* 配置文件中默认有此下配置：

```
save 900 1
save 300 10
save 60 10000
```

save 开头的一行就是持久化配置，可以配置多个条件（每行配置一个条件），每个条件之间是『或』的关系，*`save 900 1`* 表示 900 秒钟（15 分钟）内至少 1 个键被更改则进行快照，*`save 300 10`* 表示 300 秒（5 分钟）内至少 10 个键被更改则进行快照。

Redis 启动后会读取 RDB 快照文件，将数据从硬盘载入到内存。根据数据量大小与结构和服务器性能不同，这个时间也不同。通常将记录一千万个字符串类型键、大小为 1GB 的快照文件载入到内存中需要花费 20～30 秒钟。

但是 RDB 方式实现持久化有个问题啊：一旦 Redis 异常（突然）退出，就会丢失最后一次快照以后更改的所有数据。因此在使用 RDB 方式时，需要根据实际情况，调整配置中的参数，以便将数据的遗失控制在可接受范围内。

## AOF 方式

默认情况下 Redis 没有开启 AOF（append only file）方式的持久化，可以通过配置文件中的 *`appendonly`* 参数开启：

```
appendonly yes
```

开启 AOF 持久化后每执行一条会更改 Redis 中的数据的命令，Redis 就会将该命令写入硬盘中的 AOF 文件。AOF 文件的保存位置和 RDB 文件的位置相同，都是通过 *`dir`* 参数设置的，默认的文件名是 *`appendonly.aof`*，可以通过 *`appendfilename`* 参数修改：*`appendfilename appendonly.aof`*
